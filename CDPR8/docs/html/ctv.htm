<!DOCTYPE html>
<html lang="en">
<!-- ctv.htm - Tabula Vigilans Manual - updated for vn 1.5 -->
<html>

<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Tabula Vigilans Manual</title>
<meta charset="UTF-8" />
	<link rel = "stylesheet"
	 type = "text/css"
	 href = "tv.css" />
<link rel="icon"  href="images/cdp_favicon.ico">
    <style>
	a { text-decoration: none }
	a:hover { color:#FF3333; text-decoration: underline }          	
    </style>
</head>

<body>

<div id = "left"> <!-- ------------------------------ -->

<h2 style="color:black;" align=center id="INDEXTOP"><i>Tabula<br> Vigilans</i><br> Index</h2>

  <p>
  <nav>

  <dl>
  <dt><a href="ccdpndex.htm" Target="_top"><b>CDP MAIN INDEX</b></a>
  <dt><a href="graphic.htm" Target="_top"><b>GRAPHIC INDEX</b></a> 
  <hr>

<dl>
<dt><a href="#RULESLIST" ><b>List of Keywords</b></a>
<dt><a href="#TVQUICKFIND"><b>Function Quick Find</b></a>
<dt><a href="#KEYREF"><b>TV Keyword Buttons</b></a>
<dt><a href="#DEMO"><b>Demonstration Scripts</b></a>
<hr>
<h3 style="color:black;">INTRODUCTORY</h3>
<dt><b>1.0 <a href="#INTRODUCTION">Introduction</b></a>
	<ul>
	<li><b>1.01 <a href="#USE">How to use the program</b></a></li>
	<li><b>1.1 <a href="#TERMS">Some terms defined</b></a></li>
	<li><b>1.2 <a href="#FORMAT" >Format of the <i>Tabula Vigilans</i> script</b></a></li>
	<li><b>1.3 <a href="#INITIALISATION">Initialisation rules</b></a></li>
	<li><b>1.31 <a href="#INCLUDE">#include</b></a></li>
	<li><b>1.32 <a href="#TABLESSIZED">Tables (sized)</b></a></li>
	<li><b>1.33 <a href="#TABLESUNSIZED">Tables (unsized)</b></a></li>
    <li><b>1.34 <a href="#STRINGTABLES">String Tables</b></a></li>
	<li><b>1.4 <a href="#PROCEDURE">Procedure format</b></a></li>
	<li><b>1.5 <a href="#COMMENTS">Comments</b></a></li>
	</ul>
<br>
<dt><b>2.0 <a href="#RULELINES" >Rule-Lines</b></a>
	<ul>
	<li><b>2.1 <a href="#ASSIGNMENTS" >Assignments</a></b></li>
	<li><b>2.11 <a href="#MATHEMATICAL" >Mathematical expressions</a></b> </li>
	<li><b>2.12 <a href="#EXPRESSION" >Expression shorthand</a></b></li> 
	<li><b>2.13 <a href="#MATHFUNC" >Mathematical functions</a></b></li>
	<li><b>2.2 <a href="#RULES" >Rules</a></b></li>
	<li><b>2.3 <a href="#TRY" >try</b></a></b></li>
	</ul>

<br>
<dt><b>3.0 <a href="#CONTROLFLOW" >Control flow</b></a>
	<ul>
	<li><b>3.1 <a href="#WHILE" >The <i>while</i> loop</b></a> </li>
	<li><b>3.2 <a href="#FOR" >The <i>for()</i> loop</b></a> </li>
	<li><b>3.3 <a href="#CONDITIONAL" >Conditional evaluations</b></a></li> 
	<li><b>3.31 <a href="#IF" ><i>if()</i></b></a></li>
	<li><b>3.32 <a href="#SWITCHON" >switchon</b></a></li>
	<li><b>3.4 <a href="#MOVINGBETWEEN" >Moving between procedures</b></a></li> 
	</ul>

<br>
<dt><b>4.0 <a href="#CELLS&TABLES" >Cells and Tables</b></a>
	<ul>
	<li><b>4.1 <a href="#GLOBALLOCAL" >Global and local cells </b></a></li> 
	<li><b>4.2 <a href="#INDEXING" >Indexing of tables </b> </a> </li>
	<li><b>4.21 <a href="#FRACTIONAL" >Fractional indexing </b></a></li>
	<li><b>4.3 <a href="#TPOINTERS" >Table pointers </b></a></li>
	</ul>
 

<hr>
<h3 id="TVQUICKFIND"  style="color:black;">KEYWORDS</h3>
<dt><b>TV Functions</b>
<ul>
<li><a href="#ABS" ><b>abs</b></a></li>
<li><a href="#ADDDEC" ><b>add_dec</b></a></li>
<li><a href="#ALLLOCKED" ><b>alllocked</b></a></li>
<li><a href="#ANYLOCKED" ><b>anylocked</b></a></li>
<li><a href="#ARCCOSINE" ><b>arccosine</b></a></li>
<li><a href="#ARCSINE" ><b>arcsine</b></a></li>
<li><a href="#ARCTANGENT" ><b>arctangent</b></a></li>
<li><a href="#ARG" ><b>arg</b></a></li>
<li><a href="#ARGC" ><b>argc</b></a></li>
<li><a href="#ARGS" ><b>args</b></a></li>
<li><a href="#BREAK" ><b>break</b></a></li>
<li><a href="#CALL" ><b>call</b></a></li>
<li><a href="#SWITCHON2" ><b>case</b></a></li>
<li><a href="#CLOSE_STOREFILES" ><b>close_storefiles</b></a></li>
<li><a href="#CLS" ><b>cls</b></a></li>
<li><a href="#CONTINUE" ><b>continue</b></a></li>
<li><a href="#COMPARE" ><b>compare</b></a></li>
<li><a href="#CONTROLOUT" ><b>control-out</b></a></li>
<li><a href="#COPY" ><b>copy</b></a></li>
<li><a href="#COPYTABLE" ><b>copy_table</b></a></li>
<li><a href="#COSINE" ><b>cosine</b></a></li>
<li><a href="#DIMENSIONS" ><b>dimensions</b></a></li>
<li><a href="#DIMSIZE" ><b>dimsize</b></a></li>
<li><a href="#EMBED" ><b>embed</b></a></li>
<li><a href="#END" ><b>end</b></a></li>
<li><a href="#EXP" ><b>exp</b></a></li>
<li><a href="#FAIL" ><b>fail</b></a></li>
<li><a href="#FILLTABLE" ><b>fill_table</b></a></li>
<li><a href="#FOLD" ><b>fold</b></a></li>
<li><a href="#FORRULE" ><b>for</b></a></li>
<li><a href="#GAMMA" ><b>gamma</b></a></li>
<li><a href="#GAUSS" ><b>gauss</b></a></li>
<li><a href="#GENERATE" ><b>generate</b></a></li>
<li><a href="#IF" ><b>if</b></a></li>
<li><a href="#INCLUDE" ><b>#include</b></a></li>
<li><a href="#INT" ><b>int</b></a></li>
<li><a href="#INT2STRING" ><b>int2string</b></a></li>
<li><a href="#INTERPTABLE" ><b>interp_table</b></a></li>
<li><a href="#LIM" ><b>lim</b></a></li>
<li><a href="#LIN" ><b>lin</b></a></li>
<li><a href="#LINTRANS" ><b>lintrans</b></a></li>
<li><a href="#LOCAL" ><b>local</b></a></li>
<li><a href="#LOCK" ><b>lock</b></a></li>
<li><a href="#LOG" ><b>log</b></a></li>
<li><a href="#LOG10" ><b>log10</b></a></li>
<li><a href="#LOOP" ><b>loop</b></a></li>
<li><a href="#MAX" ><b>max</b></a></li>
<li><a href="#MEAN" ><b>mean</b></a></li>
<li><a href="#MESSAGE" ><b>message</b></a></li>
<li><a href="#MESSAG1" ><b>messag1</b></a></li>
<li><a href="#MIDICHORD" ><b>midichord</b></a></li>
<li><a href="#MIDIECHO" ><b>midiecho</b></a></li>
<li><a href="#MIDIIN" ><b>midiin</b></a></li>
<li><a href="#MIDIOUT" ><b>midiout</b></a></li>
<li><a href="#MIDISET" ><b>midiset</b></a></li>
<li><a href="#MIN" ><b>min</b></a></li>
<li><a href="#MOUSE" ><b>mouse</b></a></li>
<li><a href="#MULT" ><b>mult</b></a></li>
<li><a href="#MULTTABLE" ><b>mult_table</b></a></li>
<li><a href="#NATLOG" ><b>natlog</b></a></li>
<li><a href="#NUM2STRING" ><b>num2string</b></a></li>
<li><a href="#OFFSETTABLE" ><b>offset_table</b></a></li>
<li><a href="#PERM" ><b>perm</b></a></li>
<li><a href="#PITCHBEND" ><b>pitchbend</b></a></li>
<li><a href="#POP" ><b>pop</b></a></li>
<li><a href="#POWER" ><b>power</b></a></li>
<li><a href="#PRINT" ><b>print</b></a></li>
<li><a href="#PROBE" ><b>probe</b></a></li>
<li><a href="#PROBI" ><b>probi</b></a></li>
<li><a href="#RAND" ><b>rand</b></a></li>
<li><a href="#RANDOM" ><b>random</b></a></li>
<li><a href="#RETURN" ><b>return</b></a></li>
<li><a href="#ROUND" ><b>round</b></a></li>
<li><a href="#SCALETABLE" ><b>scale_table</b></a></li>
<li><a href="#SCHEDULE" ><b>schedule</b></a></li>
<li><a href="#SEG" ><b>seg</b></a></li>
<li><a href="#SHIFT" ><b>shift</b></a></li>
<li><a href="#SHOWARGS" ><b>showargs</b></a></li>
<li><a href="#SINE" ><b>sine</b></a></li>
<li><a href="#SORT" ><b>sort</b></a></li>
<li><a href="#SQRT" ><b>sqrt</b></a></li>
<!--
<li><a href="#SPAWN" ><b>spawn</b></a></li>
-->
<li><a href="#STOREDIGITS" ><b>store_digits</b></a></li>
<li><a href="#STORE" ><b>store</b></a></li>
<li><a href="#STORF" ><b>storf</b></a></li>
<li><a href="#STORI" ><b>stori</b></a></li>
<li><a href="#STOREFILE" ><b>storefile</b></a></li>
<li><a href="#STORSTR" ><b>storstr</b></a></li>
<li><a href="#SUBST" ><b>subst</b></a></li>
<li><a href="#SUM" ><b>sum</b></a></li>
<li><a href="#SUMTABLE" ><b>sum_table</b></a></li>
<li><a href="#SWAP" ><b>swap</b></a></li>
<li><a href="#SWITCHON2" ><b>switchon</b></a></li>
<li><a href="#SYSTEM" ><b>system</b></a></li>
<li><a href="#TABLE" ><b>table</b></a></li>
<li><a href="#TANGENT" ><b>tangent</b></a></li>
<li><a href="#TIME" ><b>time</b></a></li>
<li><a href="#TRIGGER" ><b>trigger</b></a></li>
<li><a href="#TRYRULE" ><b>try</b></a></li>
<li><a href="#UNLOCK" ><b>unlock</b></a></li>
<li><a href="#WAIT" ><b>wait</b></a></li>
<li><a href="#WHILERULE" ><b>while</b></a></li>
<li><a href="#XAD" ><b>xad</b></a></li>
<li><a href="#XAR" ><b>xar</b></a></li>
</ul>


</dl>
</p>

</div>  <!----------------- End of left index panel ----------------------->

<div id = "right"> <!-- Keep headlines here so index goes to top of page -->

   <div id = "head">


   <div align=center>
   <br>
   <img src="images/cdplogo2.jpg" ALT="CDP Logo">
   </div>
<p>
<br>
</p>

<h1 align=center>TABULA VIGILANS</h1>
<h2 align="center">User Manual &#150; Version 1.5</h2>
<h2  align=center>by Richard Orton</h2>
<h3 align=center>HTML version ed. A. Endrich</h3>

<!--   Copyright now in Footer
<p align=center>
<b>&#169; 1994-2012, Richard Orton &amp; Composers' Desktop Project</b>
</p>
-->

<h2 align=center>Acknowledgements</h2>

<p>
<blockquote>
There are many who have assisted in the design of <i>Tabula Vigilans</i>,
but I should like to single out for special mention Martin Atkins, who
helped considerably with a complete re-design of the parser using the
Yacc utility.  He and many others helped by simply being available to
discuss the design of rules: &nbsp;I should like to mention especially Archer
Endrich, of the Composers' Desktop Project, and my colleagues at the
University of York, Ross Kirk, Andy Hunt, Tony Myatt, David Malham,
Nick Fells and Mark Pearson.

</p>

<p>Richard Orton<br>York, 1994 &#150; 2012;  Willoughby on the Wolds, 2007</p>
</blockquote>

   </div>  <!-- End of 'head' -->

<!-- ========================================================================= -->
<h1 id="CONTENTS" align=center>CONTENTS &#150; INTRODUCING THE ENVIRONMENT</h1>

<p>

<ul>

<li><a href="#RULESLIST"><b>List of Keywords</b>,</a> with descriptions</li>
<li><a href="#TVFUNCCHART"><b>Button Chart of keywords</b></a> (Rules)</li>
<br>
<li><a href="#OVERVIEW"><b>OVERVIEW</b></a>
	<ul>
	<li><b>1.0 <a href="#INTRODUCTION">Introduction</b></a></li>
	<li><b>1.01 <a href="#USE">How to use the program</a></b></li>
	<li><b>1.1  <a href="#TERMS">Some terms defined </b></a> </li>
	<li><b>1.2 <a href="#FORMAT">Format </a> </b>of the <i>Tabula Vigilans</i> script</li>
	<li><b>1.3 <a href="#INITIALISATION">Initialisation rules</b></a> </li>
	<li><b>1.4 <a href="#PROCEDURE">Procedure format</b></a></li>
	<li><b>1.5 <a href="#COMMENTS">Comments</b></a></li>
	</ul>
	</li>
<br>
<li><b>2.0 <a href="#RULELINES">Rule-Lines</b></a>
	<ul>
	<li><b>2.1 <a href="#ASSIGNMENTS">Assignments</b></a></li>
	<li><b>2.11 <a href="#MATHEMATICAL">Mathematical expressions</b> </a></li> 
	<li><b>2.12 <a href="#EXPRESSION">Expression shorthand</b> </a></li>
	<li><b>2.13 <a href="#MATHFUNC">Mathematical functions</b></a></li>
	<li><b>2.2 <a href="#RULES">Rules</b> </a></li>
	<li><b>2.3 <a href="#TRY">try</b> </a></li>
	</ul>
	</li>
<br>
<li><b>3.0 <a href="#CONTROLFLOW">Control flow</b> </a>
	<ul>
	<li><b>3.1 <a href="#WHILE">The <i>while</i> loop </b> </a></li> 
	<li><b>3.2 <a href="#FOR">The <i>for()</i>loop </b> </a></li> 
	<li><b>3.3 <a href="#CONDITIONAL">Conditional evaluations</b> </a></li> 
	<li><b>3.4 <a href="#MOVINGBETWEEN">Moving between procedures</b> </a></li> 
	</ul>
	</li>
<br>
<li><b>4.0 <a href="#CELLS&TABLES">Cells and Tables</b> </a>
	<ul>
	<li><b>4.1 <a href="#GLOBALLOCAL">Global and local cells</b> </a></li> 
	<li><b>4.2 <a href="#INDEXING">Indexing of tables</b> </a></li> 
	<li><b>4.21 <a href="#FRACTIONAL">Fractional ndexing</b> </a></li>
	<li><b>4.3 <a href="#TPOINTERS">Table pointers</b> </a></li>
	</ul>
	</li>
<br>
<li><b><a href="#KEYREF">KEYWORDS: REFERENCE SECTION</b></a></li>
<br>
<li><b><a href="#DEMO">DEMONSTRATION SCRIPTS</b> </a></li>

</ul>

</p>

<hr><!-- ******************** KEYWORDS TABLE****************** -->


<h2 align=center id="RULESLIST">LIST OF KEYWORDS</a></h2>

<div align=center>
<table  border=3 cellspacing=0 cellpadding=7>
	<tr>
		<td><a href="#ABS"><b>abs</b></a></td>
		<td>Mathematical</td>
		<td>convert argument to absolute value</td>
	</tr>
	<tr>
		<td><a href="#ADDDEC"><b>add_dec</b></a></td>
		<td>Rule</td>
		<td>conditionally add or decrement a value to a cell</td>
	</tr>
	<tr>
		<td><a href="#ALLLOCKED"><b>alllocked</b></a></td>
		<td>Rule</td>
		<td>test whether all of a list of cells are 'locked'</td>
	</tr>
	<tr>
		<td><a href="#ANYLOCKED"><b>anylocked</b></a></td>
		<td>Rule</td>
		<td>test whether any of a list of cells are 'locked'</td>
	</tr>
	<tr>
		<td><a href="#ARCCOSINE"><b>arccosine</b></a></td>
		<td>Mathematical</td>
		<td>the arccosine of x</td>
	</tr>
	<tr>
		<td><a href="#ARCSINE"><b>arcsine</b></a></td>
		<td>Mathematical</td>
		<td>the arcsine of x</td>
	</tr>
	<tr>
		<td><a href="#ARCTANGENT"><b>arctangent</b></a></td>
		<td>Mathematical</td>
		<td>the arctangent of x</td>
	</tr>
	<tr>
		<td><a href="#ARG"><b>arg</b></a></td>
		<td>Mathematical</td>
		<td>employ a value passed from the command line</td>
	</tr>
	<tr>
		<td><a href="#ARGC"><b>argc</b></a></td>
		<td>Command line</td>
		<td>tests for correct no. of arguments on command line</td>
	</tr>

	<tr>
		<td><a href="#ARGS"><b>args</b></a></td>
		<td>Command line</td>
		<td>employ a string passed from the command line</td>
	</tr>
	<tr>
		<td><a href="#BREAK"><b>break</b></a></td>
		<td>Control-flow</td>
		<td>break out of a <i>for</i> or <i>while</i> loop,
		with or without using a label </td>
	</tr>
	<tr>
		<td><a href="#CALL"><b>call</b></a></td>
		<td>Control-flow</td>
		<td>call another procedure</td>
	</tr>

	<tr>
		<td><a href="#CLOSE_STOREFILES"><b>close_storefiles</b></a></td>
		<td>Control-flow</td>
		<td>close all open storefiles</td>
	</tr>
	<tr>
		<td><a href="#CLS"><b>cls</b></a></td>
		<td>Rule</td>
		<td>clear screen</td>
	</tr>
	<tr>
		<td><a href="#CONTINUE"><b>continue</b></a></td>
		<td>Control-flow</td>
		<td>continue with a <i>for</i> or <i>while</i> loop,
		with or without using a label</td>
	</tr>
	<tr>
		<td><a href="#COMPARE"><b>compare</b></a></td>
		<td>Rule</td>
		<td>compare two input tables</td>
	</tr>
	<tr>
		<td><a href="#CONTROLOUT"><b>control-out</b></a></td>
		<td>Rule</td>
		<td>send a MIDI control message</td>
	</tr>
	<tr>
		<td><a href="#COPY"><b>copy</b></a></td>
		<td>Rule</td>
		<td>copy the value of an input cell into one
		or more output cells</td>
	</tr>
	<tr>
		<td><a href="#COPYTABLE"><b>copy_table</b></a></td>
		<td>Rule</td>
		<td>copy the contents of one table to another</td>
	</tr>
	<tr>
		<td><a href="#COSINE"><b>cosine</b></a></td>
		<td>Mathematical</td>
		<td>the cosine of x</td>
	</tr>
	<tr>
		<td><a href="#DIMENSIONS"><b>dimensions</b></a></td>
		<td>Mathematical</td>
		<td>return the number of dimensions of a table</td>
	</tr>
	<tr>
		<td><a href="#DIMSIZE"><b>dimsize</b></a></td>
		<td>Mathematical</td>
		<td>return the number of cells in a table dimension</td>
	</tr>
	<tr>
		<td><a href="#EMBED"><b>embed</b></a></td>
		<td>Rule</td>
		<td>embed tables</td>
	</tr>
	<tr>
		<td><a href="#END"><b>end</b></a></td>
		<td>Control-flow</td>
		<td>end performance</td>
	</tr>
	<tr>
		<td><a href="#EXP"><b>end</b></a></td>
		<td>Rule</td>
		<td>exponential time-varying output</td>
	</tr>
	<tr>
		<td><a href="#FAIL"><b>fail</b></a></td>
		<td>Rule</td>
		<td>used for testing and debugging</td>
	</tr>
	<tr>
		<td><a href="#FILLTABLE"><b>fill_table</b></a></td>
		<td>Rule</td>
		<td>fill a table with values</td>
	</tr>
	<tr>
		<td><a href="#FOLD"><b>fold</b></a></td>
		<td>Rule</td>
		<td>time-based embedding of tables</td>
	</tr>
	<tr>
		<td><a href="#FOR"><b>for</b></a></td>
		<td>Control-flow</td>
		<td>set up a loop counter</td>
	</tr>
	<tr>
		<td><a href="#GAMMA"><b>gamma</b></a></td>
		<td>Mathematical</td>
		<td>return a random number with a Gamma distribution
		probability</td>
	</tr>
	<tr>
		<td><a href="#GAUSS"><b>gauss</b></a></td>
		<td>Mathematical</td>
		<td>return a random number with a Gaussian distribution
		probability</td>
	</tr>
	<tr>
		<td><a href="#GENERATE"><b>generate</b></a></td>
		<td>Rule</td>
		<td>generate first-order set of values in output table
		from an input table</td>
	</tr>
	<tr>
		<td><a href="#IF"><b>if</b></a></td>
		<td>Control-flow</td>
		<td>conditional branch, with or without the 'else'
		construct</td>
	</tr>
	<tr>
		<td><a href="#INCLUDE"><b>#include</b></a></td>
		<td>Initialisation</td>
		<td>include another TV script</td>
	</tr>
	<tr>
		<td><a href="#INT"><b>int</b></a></td>
		<td>Mathematical</td>
		<td>return the integer value of a number</td>
	</tr>
	<tr>
		<td><a href="#INT2STRING"><b>int2string</b></a></td>
		<td>Type conversion</td>
		<td>converts an integer value to a string</td>
	</tr>
	<tr>
		<td><a href="#INTERPTABLE"><b>interp_table</b></a></td>
		<td>Rule</td>
		<td>interpolate a value between each corresponding
		value in two tables</td>
	</tr>
	<tr>
		<td><a href="#LIM"><b>lim</b></a></td>
		<td>Rule</td>
		<td>constrain a cell to lie within given limits</td>
	</tr>
	<tr>
		<td><a href="#LIN"><b>lin</b></a></td>
		<td>Rule</td>
		<td>create a linear time-varying output</td>
	</tr>
	<tr>
		<td><a href="#LINTRANS"><b>lintrans</b></a></td>
		<td>Rule</td>
		<td>multiply and add combined in a single (linear)
		operation</td>
	</tr>
	<tr>
		<td><a href="#LOCAL"><b>local</b></a></td>
		<td>Control-flow</td>
		<td>declare a cell to be local (private) to the current
		procedure</td>
	</tr>
	<tr>
		<td><a href="#LOCK"><b>lock</b></a></td>
		<td>Rule</td>
		<td>lock one or more cells</td>
	</tr>
	<tr>
		<td><a href="#LOG"><b>log</b></a></td>
		<td>Rule</td>
		<td>create a logarithmic time-varying ouput</td>
	</tr>
	<tr>
		<td><a href="#LOG10"><b>log10</b></a></td>
		<td>Rule</td>
		<td>create a logarithmic time-varying ouput</td>
	</tr>
	<tr>
		<td><a href="#LOOP"><b>loop</b></a></td>
		<td>Control-flow</td>
		<td>return control-flow to to the start of the current
		procedure</td>
	</tr>
	<tr>
		<td><a href="#MAX"><b>max</b></a></td>
		<td>Rule</td>
		<td>output the maximum value of a number of input
		arguments</td>
	</tr>
	<tr>
		<td><a href="#MEAN"><b>mean</b></a></td>
		<td>Rule</td>
		<td>output the average, or mean, of a number of input
		arguments</td>
	</tr>
	<tr>
		<td><a href="#MESSAGE"><b>message</b></a></td>
		<td>Rule</td>
		<td>output a message string to the console</td>
	</tr>
	<tr>
		<td><a href="#MESSAG1"><b>messag1</b></a></td>
		<td>Rule</td>
		<td>output a message string to the console only
		the first time it is called</td>
	</tr>
	<tr>
		<td><a href="#MIDICHORD"><b>midichord</b></a></td>
		<td>Rule</td>
		<td>output a chord to the designated MIDI channel</td>
	</tr>
	<tr>
		<td><a href="#MIDIECHO"><b>midiecho</b></a></td>
		<td>Rule</td>
		<td>output immediately (echo) a MIDI event</td>
	</tr>
	<tr>
		<td><a href="#MIDIIN"><b>midiin</b></a></td>
		<td>Rule</td>
		<td>collect and store input MIDI data</td>
	</tr>
	<tr>
		<td><a href="#MIDIOUT"><b>midiout</b></a></td>
		<td>Rule</td>
		<td>output a MIDI message</td>
	</tr>
	<tr>
		<td><a href="#MIDISET"><b>midiset</b></a></td>
		<td>Rule</td>
		<td>set instruments to specific MIDI channels</td>
	</tr>
	<tr>
		<td><a href="#MIN"><b>min</b></a></td>
		<td>Rule</td>
		<td>output the minimum value of up to nine input cells</td>
	</tr>
	<tr>
		<td><a href="#MOUSE"><b>mouse</b></a></td>
		<td>Rule</td>
		<td>specify mouse position</td>
	</tr>
	<tr>
		<td><a href="#MULT"><b>mult</b></a></td>
		<td>Rule</td>
		<td>multiply the values of any number of input cells</td>
	</tr>
	<tr>
		<td><a href="#MULTTABLE"><b>mult_table</b></a></td>
		<td>Rule</td>
		<td>multiply the values of a table by those of another table</td>
	</tr>
	<tr>
		<td><a href="#NUM2STRING"><b>num2string</b></a></td>
		<td>Type conversion</td>
		<td>converts a floating-point value to a string</td>
	</tr>
	<tr>
		<td><a href="#OFFSETTABLE"><b>offset_table</b></a></td>
		<td>Rule</td>
		<td>offset the contents of a table by a value</td>
	</tr>
	<tr>
		<td><a href="#PERM"><b>perm</b></a></td>
		<td>Rule</td>
		<td>randomly permutate the contents of the input table</td>
	</tr>
	<tr>
		<td><a href="#PITCHBEND"><b>pitchbend</b></a></td>
		<td>Rule</td>
		<td>send a MIDI pitchbend message</td>
	</tr>
	<tr>
		<td><a href="#POP"><b>pop</b></a></td>
		<td>Rule</td>
		<td>fractal algorithm which employs an output cell and
		an input value</td>
	</tr>
	<tr>
		<td><a href="#POWER"><b>power</b></a></td>
		<td>Mathematical</td>
		<td>power function</td>
	</tr>
	<tr>
		<td><a href="#PRINT"><b>print</b></a></td>
		<td>Rule</td>
		<td>print an input argument to the console</td>
	</tr>
	<tr>
		<td><a href="#PROBE"><b>probe</b></a></td>
		<td>Rule</td>
		<td>display the input arguments to 2 decimal places on
		the console</td>
	</tr>
	<tr>
		<td><a href="#PROBI"><b>probi</b></a></td>
		<td>Rule</td>
		<td>display values as integers on the console</td>
	</tr>
	<tr>
		<td><a href="#RAND"><b>rand</b></a></td>
		<td>Mathematical</td>
		<td>generate a random number between 0 and 1</td>
	</tr>
	<tr>
		<td><a href="#RANDOM"><b>random</b></a></td>
		<td>Mathematical</td>
		<td>generate a random number between two specified values</td>
	</tr>
	<tr>
		<td><a href="#RETURN"><b>return</b></a></td>
		<td>Control-flow</td>
		<td>return to a previous procedure</td>
	</tr>
	<tr>
		<td><a href="#ROUND"><b>round</b></a></td>
		<td>Mathematical</td>
		<td>return the nearest rounded integer</td>
	</tr>
	<tr>
		<td><a href="#SCALETABLE"><b>scale_table</b></a></td>
		<td>Rule</td>
		<td>scale each cell in a table by a specified constant</td>
	</tr>
	<tr>
		<td><a href="#SCHEDULE"><b>schedule</b></a></td>
		<td>Rule</td>
		<td>schedule a MIDI event for later performance</td>
	</tr>
	<tr>
		<td><a href="#SEG"><b>seg</b></a></td>
		<td>Rule</td>
		<td>create a linear time-varying output</td>
	</tr>
	<tr>
		<td><a href="#SHIFT"><b>shift</b></a></td>
		<td>Rule</td>
		<td>shift contents of a table one place to the left
		(or right)</td>
	</tr>
	<tr>
		<td><a href="#SHOWARGS"><b>showargs</b></a></td>
		<td>Rule</td>
		<td>show commandline string arguments
		(or right)</td>
	</tr>
	<tr>
		<td><a href="#SINE"><b>sine</b></a></td>
		<td>Mathematical</td>
		<td>give the sine of a value in radians</td>
	</tr>
	<tr>
		<td><a href="#SORT"><b>sort</b></a></td>
		<td>Rule</td>
		<td>sort a table into ascending or descending order</td>
	</tr>
	<tr>
		<td><a href="#SQRT"><b>sqrt</b></a></td>
		<td>Mathematical</td>
		<td>give the square root of a value</td>
	</tr>
<!--
	<tr>
		<td><a href="#SPAWN"><b>spawn</b></a></td>
		<td>Operating system call</td>
		<td>spawns an external program process</td>
	</tr>
-->
	<tr>
		<td><a href="#STOREDIGITS"><b>store_digits</b></a></td>
		<td>Rule</td>
		<td>set number of decimal places to store values in a file</td>
	</tr>
	<tr>
		<td><a href="#STORE"><b>store</b></a></td>
		<td>Rule</td>
		<td>store values to 2 decimal places in a file</td>
	</tr>
	<tr>
		<td><a href="#STORF"><b>storf</b></a></td>
		<td>Rule</td>
		<td>specify filename(s) for additional store functions<br />
		</td>
	</tr>
	<tr>
		<td><a href="#STORI"><b>stori</b></a></td>
		<td>Rule</td>
		<td>store values as integers in a file</td>
	</tr>
	<tr>
		<td><a href="#STOREFILE"><b>storefile</b></a></td>
		<td>Rule</td>
		<td>specify filename(s) for (multiple) store functions<br />
		    Also see <b>storf</b></td>
	</tr>
	<tr>
		<td><a href="#STORSTR"><b>storstr</b></a></td>
		<td>Rule</td>
		<td>store an ASCII string in a file</td>
	</tr>
	<tr>
		<td><a href="#SUBST"><b>subst</b></a></td>
		<td>Rule</td>
		<td>draw values out of two input tables with statistical
		weighting</td>
	</tr>
	<tr>
		<td><a href="#SUM"><b>sum</b></a></td>
		<td>Rule</td>
		<td>sum in the output cell the input arguments</td>
	</tr>
	<tr>
		<td><a href="#SUMTABLE"><b>sum_table</b></a></td>
		<td>Rule</td>
		<td>sum successive values in two tables</td>
	</tr>

	<tr>
		<td><a href="#SWAP"><b>swap</b></a></td>
		<td>Rule</td>
		<td>swap the values of two cells</td>
	</tr>
	<tr>
		<td><a href="#SWITCHON"><b>switchon</b></a></td>
		<td>Control-flow</td>
		<td>alternate conditional branch construct</td>
	</tr>
	<tr>
		<td><a href="#SYSTEM"><b>system</b></a></td>
		<td>Operating system call</td>
		<td>passes control to a named external program</td>
	</tr>
	<tr>
		<td><a href="#TABLE"><b>table</b></a></td>
		<td>Initialisation</td>
		<td>create a table of given dimensions and sizes</td>
	</tr>
	<tr>
		<td><a href="#TANGENT"><b>tangent</b></a></td>
		<td>Mathematical</td>
		<td>the tangent of x</td>
	</tr>
	<tr>
		<td><a href="#TIME"><b>time</b></a></td>
		<td>Rule</td>
		<td>set a real-time counter</td>
	</tr>
	<tr>
		<td><a href="#TRIGGER"><b>trigger</b></a></td>
		<td>Rule</td>
		<td>set a trigger cell</td>
	</tr>
	<tr>
		<td><a href="#TRY"><b>try</b></a></td>
		<td>Mathematical</td>
		<td>ascertain the return status of a rule</td>
	</tr>
	<tr>
		<td><a href="#UNLOCK"><b>unlock</b></a></td>
		<td>Rule</td>
		<td>unlock previously locked input cells</td>
	</tr>
	<tr>
		<td><a href="#WAIT"><b>wait</b></a></td>
		<td>Rule</td>
		<td>cause a complete stay of execution for the duration
		of the input cell</td>
	</tr>
	<tr>
		<td><a href="#WHILE"><b>while</b></a></td>
		<td>Control-flow</td>
		<td>loop dependent on the evaluation of a test</td>
	</tr>
	<tr>
		<td><a href="#XAD"><b>xad</b></a></td>
		<td>Rule</td>
		<td>extract adjacent differences</td>
	</tr>
	<tr>
		<td><a href="#XAR"><b>xar</b></a></td>
		<td>Rule</td>
		<td>extract adjacent ratios</td>
	</tr>

</table>
</div>



<!-- *********************** MAIN TEXT ************************* -->
<!-- start of tvm2ae.htm -->

<h1 align=center id="OVERVIEW">Introduction to <i>Tabula Vigilans</i><br>
Getting Started &#150; Basic Terms & Concepts
</h1>

<blockquote>
<p>
<i>Tabula Vigilans</i> is a rule-based algorithmic composition system.
The user writes a <i>script</i> &#150; a text file &#150; which contains
the set of rules defining the composition.  The file is submitted to the
program which then sets up appropriate data structures for the performance
of the composition.  The performance itself consists of one or more
classes of event:
</p>

<ul type=disc>
	<li>Sound Output via MIDI synthesiser(s)
	<li>Messages to the computer console
	<li>Data written to a file
	<li>Graphical output to a screen (not incorporated in this version)
</ul>

<p>
The performance may be directed or at least partly determined by one or
more of a combination of input events:
</p>

<ul type=disc>
	<li>File and command line input
	<li>Tracking position and movement of the mouse
	<li>MIDI Input
</ul>

<p>
This Manual gives the format of the script, and lists the set of rules
which the composer may incorporate in it.
</p>
</blockquote>

<p>
<a href="#RULESLIST" ><b>Return</b></a> to List of Keywords<br>
<a href="#CONTENTS"><b>Return</b></a> to TV Contents
</p>

<hr><!------------------------- SECTION 1 -------------------------->
<h1 id="INTRODUCTION">Section 1.0&nbsp;&nbsp;Introduction</h1>

<p>
Computer systems appropriate to the version of <i>Tabula Vigilans</i>
referred to in this Manual are any of those in the PC and SGI ranges.
For the full use of MIDI and sound capabilities, additional hardware may.
sometimes be necessary. A multi-timbral MIDI synthesizer is recommended
for sound output.  The author has used the Roland <i>Sound Canvas</i>
SC-155 to test and develop the system, but example scripts may be edited
for use with any  multi-timbral synthesizer.
</p>

<h2 id="USE">Section 1.01&nbsp;&nbsp;How to use the program</h2>

<p>
Assuming the program is in the current directory, the MIDI synthesizer
is connected to the computer via MIDI leads, and the audio connections
from the synthesizer are connected to a suitable amplifier and
loudspeakers, <b>then</b>:
</p>

<ul type=disc>
<li>There should be a script in the current directory &#150; either one
supplied as an example script with the <i>Tabula Vigilans</i> release or
one made by the user with a text file editor from the rule definitions
supplied with this Manual. In due course, when many scripts are being
used, it may be convenient to have a separate directory for the scripts
and data files, with a path through to the <i>Tabula Vigilans</i> program.
In this case the current working directory will be that containing the
scripts.
<li>The overall command line looks like this: &nbsp;
<code>tv [<b>-I</b> <b>-i</b><i>N</i> <b>-o</b><i>N</i> <b>-v</b>]
<i>rule_file</i></code>
<li>The script (rule_file) should have a name with a ".tv" extension.
Let us assume for our immediate purpose that its name is "turtle.tv".
Then, from a commandline environment (such as the Windows Command Processor) the
program can be initiated by typing:
</ul>

<p>
	<blockquote>
	<code><b>tv turtle.tv &lt;RETURN&gt;</b></code><br>
	<ul type=disc>
<!--
	<li>Note that no extension is necessary in the commandline:
		this is assumed by the program.  <i>Tabula Vigilans</i>
		looks first of all for the script name as typed by the
		user;  if this is not available, it adds the extension ".tv"
		and tries again.
-->
	<li>The program parses the script, sets up all the data
		structures required, and sends a message to the console
		indicating that the performance is ready to begin.  The
		performance can then be started by pressing the
		&lt;RETURN&gt; key.  The performance will begin.  If there
		is no 'natural' end to the script, or if the user wishes
		to terminate the performance early, then the &lt;RETURN&gt;
		key (Atari) or &lt;CONTROL-C&gt; (PC and SGI) should be
		pressed again;  the performance will end with a message
		saying  how long the performance took.
	<li>If it is wished to start the performance as soon as
		possible, without referring back to the user with a
		'Ready to run performance' message, then the <b>-I</b>
		flag (for 'instantaneous') can be used, as in:
	</ul>
	<code><b>tv -I turtle.tv &lt;RETURN&gt;</b></code><br>
	<li><b>Other flags:</b>
		<ul type=disc>
		<li><b>-i</b><i>N</i> &#150; use MIDI IN device <i>N</i>
		    (<i>N</i> &gt; 0).  0 is the default, using the internal
		    synthesizer.
		<li><b>-o</b><i>N</i> &#150; use MIDI OUT device <i>N</i>
		    (<i>N</i> &gt; 0).  0 is the default, using the internal
		    synthesizer.
		<li><b>-v</b> &#150; verbose mode
		</ul>
	<li>If there is a syntax error in the script, then an
		error message will be reported to the screen;  the user
		should then check the syntax in the appropriate place in
		the script with the help of this manual.  Sometimes errors
		in the script will not be found until the script is being
		performed.  Again, an error message will be reported on
		the console, and the user will need to correct the
		script before trying a re-run.
	</ul>
	</blockquote>
</p>

<h2 id="TERMS">Section 1.1&nbsp;&nbsp;Some terms</h2>

<p>
In <i>Tabula Vigilans</i>:
</p>

<ul>
<li>The <b>script</b> is a text file that is submitted to <i>Tabula
Vigilans</i> for performance.  A script comprises one or more
<b>procedures</b>, of which one must be named <i>start()</i>.  Other
procedures may be named at will by the user.

<li>A procedure consists of the <b>procedure_name</b> followed either
by empty parentheses &#150; ( ) &#150; or parentheses containing the
name(s) of a cell whose value is being inherited from the calling
procedure,  followed by any number of lines of script enclosed in
brace delimiters:  '{' at the beginning of the procedure, and '}' to
terminate the procedure.

<li>A <b>cell</b> is a storage location in computer memory.  A cell may
contain effectively any real number.

<li>Groups of cells are called <b>tables</b>.  Tables can be of different
dimensions, and they can be of any <b>size</b> in any <b>dimension</b>.

<li>Lines of script within procedures may be of three types:
	<ol>
	<li><b>assignments</b> &#150; assigning values to cells
	<li><b>rules</b> &#150; operations upon cells and tables
	<li><b> control-flow operations</b>  &#150; determined by the
	keywords:<br>
		<blockquote>
		<b> break</b>, <b>call</b>, <b>continue</b>, <b>for</b>,
		<b>if</b>,<b> if-else</b>,<b> loop</b>, <b>return</b>,
		<b>while</b>
		</blockquote>
	</ol>
<li>A <b>primitive rule</b> (hereafter called simply 'rule') forms a
single line of text in the script.  The action that <i>Tabula Vigilans</i>
performs depends on the keyword for that primitive rule, called an
<b>opname</b> (operation  name).  Most opnames have input or output
cells or tables.  Outputs appear to the left of the opname, inputs appear
to the right.

<li>Each rule has a formal <b>template</b> as given for each opname in
this Manual.  The template indicates how many inputs or outputs the rule
is expecting, and whether they are cells, tables, or numerical values.

<li>The completed script (the <b>rule-file</b>) forms the <b>rule-set</b>
for that composition.

<li>Some operations need to occur before the performance of the script.
These are called <b>initialisation</b> rules and are defined at the head
of the script, outside any procedure.
</ul>

<h2 id="FORMAT">Section 1.2&nbsp;&nbsp;Format of the <i>Tabula Vigilans</i> script</h2>

<p>
The broad format of the rule-file is as follows:
</p>

<code>
<blockquote>
<b>
[ initialisation rules, if required ]<br>
start() procedure<br>
<p>[other procedures as required]<br>
</b>
</blockquote>
</code>


<h2 id="INITIALISATION">Section 1.3&nbsp;&nbsp;Initialisation Rules [optional]</h2>

<h3 id="INCLUDE">1.31 #include</h3>

<p>
It is possible to split a Tabula Vigilans script into two or more
files using the <b>#include</b> statement. As an example, I have a large script called
'scorebld.tv', over 2000 lines of code in length.  In order to be able
to work with a smaller file &#150; the one where the 'current development'
is, I am able to split the script into two: one called 'sb1.tv' and the
current one (in development) called 'sb2.tv'.
</p>

<p>
At the top of the 'sb2.tv' file I put the statement:
	<blockquote>
	<code>#include "sb1.tv"</code>
	</blockquote>
and by invoking the script as
	<blockquote>
	<code>tv sb2 <RETURN></code>
	</blockquote>
everything works as if it were one file.
</p>

<p>
<b>Caution:</b> Remember that error messages with line numbers will
only refer to the file with the error in &#150; so you will have to
work out which file the error is likely to be in.  I have not, thus far,
used more than two <b>#include</b> files, but in principle any number
of files could be included.
</p>

<h3 id="TABLESSIZED">1.32 Table declaration with size</h3>

<p>
<b>Table</b> requires initialisation at the head of the
script &#150; i.e., outside any procedure.  The user declares
the name, dimensions and size of the table(s) required.
</p>

<p>
Examples of table declarations are as follows:
</p>

<p>
<code><b>table PENT[20]</b></code>
</p>

<p>
Here 'table' is the opname, i.e., the <i>Tabula Vigilans</i> keyword.
The name of the table, chosen by the user, is PENT (here so named because
it is to hold a set of  PENTatonic piches) &#150; and there are going to
be 20 values, assembled in a single-dimensioned array.  There is a formal
requirement that the first letter of a table name be upper case.  By
convention, the entire table name is given in upper case, in order for
the user to distinguish easily table names from cell names, which are
always in lower case.
</p>

<p>
<code><b>table PURCELL[60][3]</b></code>
</p>

<p>
Here the name is PURCELL, and it is a two-dimensional table.  (By way
of example, this might be intended to hold 60 notes, each with an
associated duration and dynamic.)
</p>

<p>
<b>NB  To ascertain the number of dimensions a table has, count the pairs
of square brackets [ ] after the name.  The<i> size</i> of each dimension
is the number inside the squared brackets.</b>
</p>

<h3 id="TABLESUNSIZED">1.33 Table declaration without size</h3>

<p>
As long as tables are filled from an external file using
<b>fill_table</b> it is possible to declare them without specifying
the size &#150; the compiler will create a table of the correct size
automatically.  This makes it easier to use longer tables such as
those that might be generated by another program or TV script.
</p>

<p>
For example, the following will work correctly:
</p>

<p>
<font color = "#FF0000">[At the top of the file]</font><br />
<code>table PTABLE[]</code>
</p>

<p>
<font color="#FF0000">[and subsequently &#150; probably at somewhere
near the beginning of <b>start()</b>]</font><br />
<code>PTABLE fill_table "pitches.txt"</code>
</p>

<p>
and "pitches.txt" may contain any number of (e.g.) MIDI note-numbers,
as:
</p>

<p>
<code>70 73 76 45 84 60 62 ...[etc.]</code>
</p>

<h3 id="STRINGTABLES">1.34 String tables</h3>
<p>
From version 1.5, TV supports string tables. These are identified by prefixing the character <b>'</b> to the table name. String tables may be initialised with or without size (the latter being followed by <b>fill_table</b>). Multi-dimension string tables are not supported. String variables are also currently not possible:
</p>
  <blockquote>
  <code><b>
  astring = 'STRTABLE[0]
  </b></code>
  </blockquote>
<p> will produce a syntax error.
</p>


<h2 id="PROCEDURE">Section 1.4&nbsp;&nbsp;Procedure format</h2>

<p>
All procedures have the same general format:  the procedure-name
followed by parentheses, and any number of rule-lines enclosed by
opening and  closing braces.  One of the procedures must be named
<i>start()</i>, which is where the performance is to begin:
</p>

<p>
<code><b>
start()<br>
{<br>
	<blockquote>
	[ any number of rule-lines, one to a line ]<br>
	[ loop instruction, if required ]<br>
}<br>
</b></code>
</p>

<p>
The following is an example of a complete, though short, script, with
one procedure only:
</p>

<p>
<code><b>
start()<br>
{<br>
	<blockquote>
	&#47;&#47; set MIDI channel 0 to Instrument 0<br>
	midiset 0, 0<br>
	&#47;&#47; read mouse location, and scale output values<br>
	x, y mouse 48, 84, 30, 100<br>
	&#47;&#47; display x and y output values
	messag1 &quot;Pitch\tAmplitude\n&quot;<br>
	probi x, y<br>
	&#47;&#47; send a MIDI output with x as pitch, y as velocity<br>
	&#47;&#47; and a randomly-derived duration<br>
	midiout 0, x, y, 0.2 * int(random(1, 4))<br>
	</blockquote>
loop<br>
}<br>
</b></code>
</p>

<p>
Other procedures follow the same broad format,  but may be named  freely
excluding only <i>Tabula Vigilans</i> keywords.  Each is indicated by
parentheses <b>( )</b> after the procedure-name, in a format similar to
that of the <b>start( )</b> procedure, and enclosed in
braces, e.g.:
</p>

<p>
<code><b>watery()<br>
{<br>
</b></code>
</p>

<p>
Again, within the procedure, the keyword 'loop' can be employed to send
control back to the beginning of the procedure (in this case, to the
beginning of  'watery').
</p>

<h2 id="COMMENTS">Section 1.5 Comments</h2>

<p>
A user comment may be placed in a script at any point after a pair of
forward slashes (&#47;&#47;).  These have the special meaning for <i>Tabula
Vigilans</i> that the rest of the line is ignored. Such comments may
also be used in any data files (see Manual entry for <b>fill_table</b>)
created for performance.
</p>

<p>
<a href="#RULESLIST" ><b>Return</b></a> to List of Keywords<br>
<a href="#CONTENTS"><b>Return</b></a> to TV Contents
</p>

<hr><!------------------------- SECTION 2 -------------------------->
<h1 id="RULELINES">Section 2.0&nbsp;&nbsp;Rule-Lines</h1>

<p>
Rule-lines in the <i>Tabula Vigilans</i> script may be one of three
types: assignments, rules, or control-flow indicators.
</p>

<h2 id="ASSIGNMENTS">Section 2.1&nbsp;&nbsp;Assignments</h2>

<p>An assignment takes the form cell_name = expression, e.g.
</p>

<p>
<code><b>a = 0.25</b></code>
</p>

<p>
where a cell (whose name here is 'a') is explicitly assigned a numerical
value. The following assignment
</p>

<p>
<code><b>a = b</b></code>
</p>

<p>
means that the value of cell 'a' is given the same numerical value as
that of cell 'b'.
</p>

<h2 id="MATHEMATICAL">Section 2.11&nbsp;&nbsp;Mathematical Expressions
in assignments
</h2>

<p>More complex expressions may be evaluated in assignments and as input
arguments to rules and call, etc.. For example,
</p>

<p>
<code><b>(b * c)/d</b></code>
</p>

<p>
is a valid expression.  The mathematical operators that can be used in
assignments are:
</p>

<p>
<div align=center>
<table border=3 cellpadding=7>
<tr>
	<td align=center><b>+</b></td>
	<td align=center><b>-</b></td>
	<td align=center><b>*</b></td>
	<td align=center><b>&#47;</b></td>
</tr>

<tr>
	<td align=center><b>%</b></td>
	<td align=center><b>^</b></td>
	<td align=center><b>&amp;&amp;</b></td>
	<td align=center><b>&#124;&#124;</b></td>
</tr>

<tr>
	<td align=center><b>plus</b></td>
	<td align=center><b>minus</b></td>
	<td align=center><b>multiply</b></td>
	<td align=center><b>divide</b></td>
</tr>

<tr>
	<td align=center><b>modulo</b></td>
	<td align=center><b>power</b></td>
	<td align=center><b>logical AND</b></td>
	<td align=center><b>logical OR</b></td>
</tr>

</table>
</div>
</p>

<p>
Parentheses may be used to group items in an expression. For example,
</p>

<p>
<code><b>b^c&#47;d</b></code>
</p>

<p>
is different from
</p>

<p>
<code><b>b^(c&#47;d)</b></code>
</p>

<p>
In such cases, parentheses may be used to force the operators into the
associations the user intends.
</p>

<h2 id="EXPRESSION">Section 2.12&nbsp;&nbsp;Expression shorthand</h2>

<p>Some expression shorthand has been implemented, adopted from 'C'.
These are given below, with their 'longhand' form:  the forms are
identical in meaning:
</p>

<p>
<div align=center>
<table border=3 cellpadding=7>
<caption><b>Expression Shorthand &amp; Longhand</b></caption>

<tr>
	<th><b>Shorthand</b></th>
	<th><b>Longhand</b></th>
</tr>

<tr>
	<td><b>a = ++b</b></td>
	<td><b>b = b + 1</b><br>
	<b>a = b</b></td>
</tr>

<tr>
	<td><b>a = b++</b></td>
	<td><b>a = b</b><br>
	<b>b = b + 1</b></td>
</tr>

<tr>
	<td><b>a = --b</b></td>
	<td><b>b = b - 1</b><br>
	<b>a = b</b></td>
</tr>

<tr>
	<td><b>a = b--</b></td>
	<td><b>a = b</b><br>
	<b>b = b - 1</b></td>
</tr>

<tr>
	<td><b>a += b</b></td>
	<td><b>a = a + b</b></td>
</tr>

<tr>
	<td><b>a -= b</b></td>
	<td><b>a = a - b</b></td>
</tr>

<tr>
	<td><b>a *= b</b></td>
	<td><b>a = a * b</b></td>
</tr>

<tr>
	<td><b>a &#47;= b</b></td>
	<td><b>a = a &#47; b</b></td>
</tr>

<tr>
	<td><b>a %= b</b></td>
	<td><b>a = a % b</b></td>
</tr>

</table>
</div>
</p>

<h2 id="MATHFUNC">Section 2.13&nbsp;&nbsp;Mathematical Functions</h2>

<p>
There is a group of mathematical functions that can be used  within
assignments or as input arguments to rules.  These are listed below,
together with the full name of the value they return:
</p>

<div align=center>
<table border=3 cellpadding=4>
<caption><b>Table of Mathematical Functions Available in <i>Tabula
Vigilans</i></b></caption>

<tr>
	<td><b>abs(x)</b></td>
	<td>absolute value of x</td>
</tr>

<tr>
	<td><b>arccosine(x)</b></td>
	<td>the arccosine of x</td>
</tr>

<tr>
	<td><b>arcsine(x)</b></td>
	<td>the arcsine of x</td>
</tr>

<tr>
	<td><b>arctangent(x)</b></td>
	<td>the arctangent of x</td>
</tr>

<tr>
	<td><b>arg(n)</b></td>
	<td>the numerical value of the nth commandline argument</td>
</tr>

<tr>
	<td><b>args(n)</b></td>
	<td>the string value of the nth commandline argument</td>
</tr>

<tr>
	<td><b>cosine(x)</b></td>
	<td>the cosine of x</td>
</tr>

<tr>
	<td><b>dimensions(TABLE)</b></td>
	<td>the number of dimensions a table has</td>
</tr>

<tr>
	<td><b>dimsize(TABLE, dimension_number)</b></td>
	<td>the size of the dimension indicated</td>
</tr>

<tr>
	<td><b>log10(x)</b></td>
	<td>the base 10 logarithm of x</td>
</tr>

<tr>
	<td><b>int(x)</b></td>
	<td>the integer value of x</td>
</tr>

<tr>
	<td><b>natlog(x)</b></td>
	<td>the natural logarithm of x</td>
</tr>

<tr>
	<td><b>power(x, n)</b></td>
	<td>x to the nth power</td>
</tr>

<tr>
	<td><b>rand()</b></td>
	<td>a random number between 0 and 1</td>
</tr>

<tr>
	<td><b>random(x, y)</b></td>
	<td>a random number between x and y</td>
</tr>

<tr>
	<td><b>round(x)</b></td>
	<td>x rounded to the nearest integer</td>
</tr>

<tr>
	<td><b>sine(x)</b></td>
	<td>the sine of x</td>
</tr>

<tr>
	<td><b>sqrt(x)</b></td>
	<td>the square root of x</td>
</tr>

<tr>
	<td><b>tangent(x)</b></td>
	<td>the tangent of x</td>
</tr>

<tr>
	<td><b>try(rule)</b></td>
	<td>the status of executing the rule</td>
</tr>
</table>
</div>

<p>
All of these mathematical functions can be used in the following form:
</p>

<p>
<code><b>a = sqrt(x)</b></code>
</p>

<p>
and also in more complex expressions such as
</p>

<p>
<code><b>1 + sqrt(x^(b&#47;7))</b></code>
</p>

<p>
<b>try</b> can be used in the same places as mathematical functions
&#150; see Section 2.3 below.
</p>

<p>
The Manual Pages below contain full descriptions of both mathematical
functions and rules.
</p>

<!-- end tvm2ae.htm -->
<!-- start of tvm3ae.htm -->


<h2 id="RULES">Section 2.2&nbsp;&nbsp;Rules</h2>

<p>
A <b>rule</b> consists of a single line of text, comprising (from left to
right) output (cell or table) name(s), opname, and input (cell or
table) name(s). Valid separators between cell/table names and the
opname are spaces or tabs, while commas may be used to separate
multiple inputs or outputs.  Each primitive rule associated with an
opname has a formal template as given in the manual pages, which
indicates how many inputs or outputs a rule should  have. For example,
some rules have no outputs, some have no inputs. Some have fixed numbers
of outputs or inputs, while others permit a variable number of them.
</p>

<p>
Cells may be named freely by the user, the only restriction being that
the first character of the name should be a lower case letter.  There
is  no restriction on the length of the name, though spaces within the
name are  not allowed: the underline character (_) may be used to separate
significant name-syllables.  Numerical values (such as 3 or -5.7) may
also be used as constants in place of cells; these may be integer or
floating point numbers as needed.
</p>

<h2 id="TRY">Section 2.3&nbsp;&nbsp;<b>try</b>&nbsp;&nbsp;- testing
the return status of a rule</h2>

<p>
The keyword <b>try</b> can be used in conjunction with a rule to
ascertain the return status of that rule.  An example where this is
very useful is with  the rule <b>midiout</b>, which outputs a MIDI
message if it is not already in the process of doing  so.  The return
status of midiout is greater than zero if it has succeeded in sending
out one or more MIDI note-on messages, and less than zero if the matching
note-off has not yet been sent.  The use of <b>try</b> will mean that
updating of channel, note,  velocity and duration parameters can take
place before the next note or notes are due to be started.
</p>

<p>
The appropriate rule-line would be in the following form:
</p>

<p>
<code>
<b>
if(try (midiout chan, note, amp, dur, 1) &gt; 0) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;....[update chan, note, amp, dur, etc]
</b>
</code>
</p>

<p>
<a href="#RULESLIST" ><b>Return</b></a> to List of Keywords<br>
<a href="#CONTENTS"><b>Return</b></a> to TV Contents
</p>

<hr><!------------------------- SECTION 3 -------------------------->
<h1 id="CONTROLFLOW">Section 3.0&nbsp;&nbsp;Control flow within a script</h1>

<p>Performance of the script begins at the <b>start()</b> procedure.
If start()is the only procedure, and if there is no loop instruction,
then there is no repeated execution, and the performance ends having
traversed the start() procedure just once!  If there is a loop
instruction, then control will be passed back to the beginning of
the start() procedure and the cycle of rules will be iterated
repeatedly.  There are, of course, methods for ending a performance
from within the script - for example, by testing some varying cell
value.  But it is possible for some performance never to have a formal
method of ending;  in these circumstances the user simply terminates
the performance by pressing the &lt;RETURN&gt; key (Atari) or
&lt;CONTROL-C&gt; (PC and SGI) on the computer console.
</p>

<h2 id="WHILE">Section 3.1&nbsp;&nbsp;The <i>while()</i> loop</h2>

<p>
Another way of creating an infinitely repeating loop is to employ a
<b>while()</b> loop.  The extent of a <b>while()</b> loop is delimited by
curly braces, as in:
</p>

<p>
<code><b>
while(x) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;....a number of rule-lines<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;....a number of rule-lines....<br>
}</b></code>
</p>

<p>
This rule tests for the condition within the parentheses, and if the
value tested (e.g. 'x') is non-zero, then the while loop is iterated.
So if the user places a constant within the while loop, as in
</p>

<p>
<code><b>
while(1) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;....<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;....<br>
}</b></code>
</p>

<p>
then clearly the value of '1' can never change, and so the performance
will continue indefinitely.
</p>

<p>
It is common for conditional tests to be set within the while
parentheses &#150; see Section 3.3, Conditional Evaluations, below.
</p>

<h2 id="FOR">Section 3.2</a>&nbsp;&nbsp;The <i>for()</i> loop</h2>

<p>
A method of controlling a definite number of executions of a loop is
provided by the <b>for()</b> mechanism.  Here a counter is set up, which
determines the number of times the loop is performed.  The form of
the for() loop is  as follows:
</p>

<p>
<code><b>
for(i = 0; i &lt; 10; i += 1) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;....<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;....<br>
}</b></code>
</p>

<p>
Within the <b>for()</b> parentheses are three subdivisions, separated by a
semicolon.  The first of these assigns the initial value to a counter,
the second contains a conditional test which, if evaluated as TRUE,
determines that the following loop of rules will be executed once more,
and  the  third indicates what action is to be taken after each iteration.
</p>

<p>
[Caveat,'C' programmers: do not use 'i++' in the last division of
for(); the formal definition of <i>Tabula Vigilans</i> demands that
this be an assignment!]
</p>

<p>
In the case shown above, 'i' is initially set to 0, the loop is
performed as long as the value of 'i' has not reached 10, and its value
is  incremented by 1 after each iteration. So in this case the loop will
be iterated 10 times. Of course, the following is also legal in
<i>Tabula Vigilans</i>:
</p>

<p>
<code><b>
for(pitch = highC; pitch &gt; lowD; pitch = pitch - interval) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;....<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;....<br>
}</b></code>
</p>

<p>
The structure of the <i>for()</i> loop is the same, but here 'highC',
'lowD' and 'interval' are cells whose values will have been set elsewhere
in the script or will have been arrived at earlier in the performance.
</p>

<h2 id="CONDITIONAL">Section 3.3</a>&nbsp;&nbsp;Conditional Evaluations:
if() and switchon</h2>

<h3 id="IF">3.31 if ... then ... else</a></h3>

<p>
One of the main control flow mechanisms is given by the <b>if()</b>
conditional branch, with or without the 'else' extension.  It may be
employed solely within a procedure, or in conjunction with the
control-flow routine call it may be used to move from one procedure
in the script to another.
</p>

<p>
The general form of <b>if()</b> is as follows:
</p>

<p>
<code><b>
if(some condition is TRUE ) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then execute the rules<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in this block<br>
}</b></code>
</p>

<p>
which may be extended by 'else' as follows:
</p>

<p>
<code><b>
if(some condition is TRUE ) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then execute the rules<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in this block<br>
}<br>
else {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move to this block<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and execute these rules instead<br>
}</b></code>
</p>

<p>
The conditional evaluations use the comparative operators below
</p>

<blockquote>
<table border=3 cellpadding=7>
<tr>
	<td><b>&lt;</b></td>
	<td>less than</td>
</tr>

<tr>
	<td><b>&gt;</b></td>
	<td>greater than</td>
</tr>

<tr>
	<td><b>==</b></td>
	<td>is equal to</td>
</tr>

<tr>
	<td><b>!=</b></td>
	<td>is NOT equal to</td>
</tr>

<tr>
	<td><b>&lt;=</b></td>
	<td>is less than or equal to</td>
</tr>

<tr>
	<td><b>&gt;=</b></td>
	<td>is greater than or equal to</td>
</tr>

<tr>
	<td><b>&amp;&amp;</b></td>
	<td>logical AND</td>
</tr>

<tr>
	<td><b>&#124;&#124;</b></td>
	<td>logical OR</td>
</tr>
</table>
</blockquote>

<p>
The following are valid forms of conditional testing:
</p>

<p>
<code><b>
if(a &lt; b)<br>
if((x&#47;3 &gt;= z * 0.5) &amp;&amp; (y != 0))
</b></code>
</p>

<p>
i.e., within the parentheses pairs of expressions have a relational
operator between them.
</p>

<p>
Note that <b>while</b> also uses the same types of conditional evaluation
as <b>if</b>.
</p>

<h3 id="SWITCHON">3.32 switchon ... case statements</a></h3>

<p>
In order to avoid chains of <b>if..then..else..</b> statements, it
is possible to use the <b>switchon ... case</b> construction.
</p>

<p>
The following script, 'swdemo.tv' should exemplify its use:
</p>

<p>
<pre><code>
start()
{
	b = int(random(0, 3.999))
	while(1) {
		cnt += 1
		message "\n"
		print cnt, 4, 0
		switchon b {
			case 0: {
				message ": Case 0 chosen"
				b = int(random(0, 3.999))
			}
			case 1: {
				message ": Case 1 chosen"
				b = int(random(0, 3.999))
			}
			case 2: {
				message ": Case 2 chosen"
				b = int(random(0, 3.999))
			}
			case 3: {
				message ": Case 3 chosen"
				b = int(random(0, 4.999))
			}
			default: {
				message ": No action. There were "
				print cnt, 4, 0
				message " iterations.\n"
				end
			}
		}
	}
}
</code></pre>
</p>

<h2 id="MOVINGBETWEEN">Section 3.4&nbsp;&nbsp;Moving between
procedures: <b>call</b></h2>

<p>
The <b>call</b> routine may be used to move from one procedure to another.
The keyword is used in the following manner:
</p>

<p>
<code><b>
call procedure_name()
</b></code>
</p>

<p>
Values may be passed to the procedure by including parameters in the
parentheses of the procedure called, as in:
</p>

<p>
<code><b>
call refrain(5)
</b></code>
</p>

<p>
<code><b>
call update(x)
</b></code>
</p>

<p>
In the first of these examples, the value 5 is passed to the procedure
'refrain';  in the second example, the current value of cell 'x' is
passed to the procedure 'update'.
</p>

<p>
Multiple values may be passed, as in the following script:
</p>

<p>
<code><b>
start()<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = 9.3<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = 77<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call proc1(x, 5, y)<br>
}</b></code>
</p>

<p>
<code><b>
proc1(f, g, h)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;probe f, g, h<br>
}</b></code>
</p>

<p>
For further examples of the use of <b>call</b> for moving between
procedures, see the Manual entries for call, return, break and continue,
and scripts in the appendices.
</p>

<p>
<a href="#RULESLIST" ><b>Return</b></a> to List of Keywords<br>
<a href="#CONTENTS"><b>Return</b></a> to TV Contents
</p>

<hr><!------------------------- SECTION 4 -------------------------->
<h1 id="CELLS&TABLES">Section 4.0&nbsp;&nbsp;Cells and Tables</h1>

<h2 id="GLOBALLOCAL">Section 4.1&nbsp;&nbsp;Global and Local cells</h2>

<p>
Cells are created by the <i>Tabula Vigilans</i> parser as it
encounters them in the script.  On creation, cells are automatically
initialised to zero, until the script assigns a value to them.  By
default, all cells are global, i.e., they can be accessed from
any procedure.
</p>

<p>
Local cells, private to a particular procedure, must however be
declared. This means that the same cell name in another procedure will
NOT be used, only the local one.  Declarations of local cells at the
head of the procedure  are made as follows:
</p>

<p>
<code><b>
local cellname
</b></code>
</p>

<h2 id="INDEXING">Section 4.2</a>&nbsp;&nbsp;Indexing of Tables</h2>

<p>Declaration of tables and their dimensions and sizes, in
initialisation rules, has already been mentioned (see Section 1.3).
Tables are collections of cells, and a cell can always be assigned a
particular value in a table by indexing the table. It is important
to note that table indices always run from zero to the table size - 1.
So, if a table has been declared
</p>

<p>
<code><b>
table&nbsp;&nbsp;&nbsp;&nbsp;PITCHES[18]
</b></code>
</p>

<p>
then the first value in the table PITCHES will be indexed as PITCHES[0]
and the last &#150; the eighteenth &#150; as PITCHES[17].  In
<i>Tabula Vigilans</i>, indices to tables are always made modulo the
table size, so no harm will be done by indexing apparently outside
the table.  PITCHES[18], for example, will give the same result as
PITCHES[0].  Even if the index goes negative, no harm will result:
PITCHES[-1] is equivalent to PITCHES[17], PITCHES[-2] equivalent to
PITCHES[16], etc. The following is enough to continually cycle round a table:
</p>

<p>
<code><b>
PITCHES[x++]
</b></code>
</p>

<p>
The index 'x' is used and then incremented each time it is accessed.
</p>

<h2 id="FRACTIONAL">Section 4.21</a>&nbsp;&nbsp;Fractional Indexing</h2>

<p>
There is an alternative form of indexing in <i>Tabula Vigilans</i>
which can prove useful:  fractional indexing.  Here the index is always
taken as fractional, i.e., lying between 0 and 1.  The notation used
is the vertical line also used for OR:  '<b>&#124;</b>', which is placed
around the index inside the square brackets:
</p>

<p>
<code><b>
PITCHES[&#124;x&#124;]
</b></code>
</p>

<p>
Here the index 'x' is taken to be a fractional index and will give the
table value x of the distance along the table.  If x is zero, then the
first value in the table will result; if x is 1, then the last value in
the table will result.  If x is 0.25, then the value returned is that
contained one quarter of the distance along the table. If x is greater
than 1, then only the fractional part of x is used as the index.  If x
is negative, then the absolute value of x is used. The main advantage
of fractional indexing is that it can be used to access arbitrary-sized
tables.
</p>

<h2 id="TPOINTERS">Section 4.3</a>&nbsp;&nbsp;Table Pointers</h2>

<p>
Tables must be initialised at the head of the script (see Section 1.3).
However, it is possible to use table pointers within a procedure simply
by naming them, and assigning them to an already existing table.  A
table pointer  might be used to point to different tables at different
moments in  a piece. The following shows the declaration of a table at
the head of the file, and, later, within a procedure, a table pointer
assigned to it:
</p>

<p>
<code><b>
table NOTES[7]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[...etc...]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[...now within a procedure...]
</b></code>
</p>

<p>
<code><b>
PITCHES = NOTES
</b></code>
</p>

<p>
It is worth noting that the fractional indexing mentioned in section
4.3 above is particularly useful when table pointers are used with
the same index pointing to differently-sized tables. For example,
suppose we have two tables A and B; A contains 13 values, B contains
29. In the following script, when the table pointer TP is changed from
A to B, the fractional index 'ndx' will still point two-thirds along
the larger table. This would be much trickier with integer indices:
</p>

<p>
<blockquote>
<code><b>
<p>
Tabula Vigilans example to demonstrate<br>
fractional indexing with table pointer
</p>

<p>
table A[7]<br>
table B[13]
</p>

<p>
start()<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#47;&#47; Initialise the tables<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i=0; i&lt;dimsize(A, 1); i+=1) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A[i] = i+1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i=0; i&lt;dimsize(B, 1); i+=1) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B[i] = 11+i<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#47;&#47; Set table pointer TP<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TP = A<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#47;&#47; Set fractional index<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ndx = 0.66<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#47;&#47; Show value of TP with fractional index<br>
</p>

<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; message &quot;Value of TP-&gt;A with fractional index 0.66\n&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print TP[|ndx|], 5, 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#47;&#47; Change TP to point to table B<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TP = B<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; message &quot;&#92;nValue of TP-&gt;B with fractional index 0.66\n&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print TP[|ndx|], 5, 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; message &quot;&#92;n&quot;<br>
}<br>
</b></code>
</blockquote>
</p>

<p>
<b>Output:</b>
</p>

<p>
<code><b>
Value of TP-&gt;A with fractional index 0.66<br>
&nbsp;&nbsp;&nbsp; 5<br>
Value of TP-&gt;B with fractional index 0.66<br>
&nbsp;&nbsp;&nbsp; 19<br>
</b></code>

<p>
<a href="#RULESLIST" ><b>Return</b></a> to List of Keywords<br>
<a href="#CONTENTS"><b>Return</b></a> to TV Contents
</p>

<hr><!------------------ KEYWORDS ------------------->
<h1 id="KEYREF">KEYWORDS: REFERENCE SECTION</h1>

<h3>
The list of currently implemented keywords comprising primitive rules
(opnames), control-flow mechanisms and mathematical functions is shown
in the following Chart, organised as buttons with which you can access
the rules themselves.
</h3>

<!-- end of tvm3ae.htm -->
<!-- start of tvm4ae.htm -->


<div align=center>
<table border=3 cellpadding=6>
<caption id="TVFUNCCHART"><b>TV Keyword Buttons</b></caption>

<tr>
<td><a href="#ABS"><b>abs</b></a></td>
<td><a href="#ADDDEC"><b>add_dec</b></a></td>
<td><a href="#ALLLOCKED"><b>alllocked</b></a></td>
<td><a href="#ANYLOCKED"><b>anylocked</b></a></td>
<td><a href="#ARCCOSINE"><b>arccosine</b></a></td>
<td><a href="#ARCSINE"><b>arcsine</b></a></td>
<td><a href="#ARCTANGENT"><b>arctangent</b></a></td>
</tr>

<tr>
<td><a href="#ARG"><b>arg</b></a></td>
<td><a href="#ARGC"><b>argc</b></a></td>
<td><a href="#ARGS"><b>args</b></a></td>
<td><a href="#BREAK"><b>break</b></a></td>
<td><a href="#CALL"><b>call</b></a></td>
<td><a href="#CLOSE_STOREFILES"><b>close_storefiles</b></a></td>
<td><a href="#CLS"><b>cls</b></a></td>
</tr>

<tr>
<td><a href="#CONTINUE"><b>continue</b></a></td>
<td><a href="#COMPARE"><b>compare</b></a></td>
<td><a href="#CONTROLOUT"><b>control-out</b></a></td>
<td><a href="#COPY"><b>copy</b></a></td>
<td><a href="#COPYTABLE"><b>copy_table</b></a></td>
<td><a href="#COSINE"><b>cosine</b></a></td>
<td><a href="#DIMENSIONS"><b>dimensions</b></a></td>
</tr>

<tr>
<td><a href="#DIMSIZE"><b>dimsize</b></a></td>
<td><a href="#EMBED"><b>embed</b></a></td>
<td><a href="#END"><b>end</b></a></td>
<td><a href="#EXP"><b>exp</b></a></td>
<td><a href="#FAIL"><b>fail</b></a></td>
<td><a href="#FILLTABLE"><b>fill_table</b></a></td>
<td><a href="#FOLD"><b>fold</b></a></td>
</tr>

<tr>
<td><a href="#FORRULE"><b>for</b></a></td>
<td><a href="#GAMMA"><b>gamma</b></a></td>
<td><a href="#GAUSS"><b>gauss</b></a></td>
<td><a href="#GENERATE"><b>generate</b></a></td>
<td><a href="#IF2"><b>if</b></a></td>
<td><a href="#INCLUDE2"><b>#include</b></a></td>
<td><a href="#INT"><b>int</b></a></td>
</tr>

<tr>
<td><a href="#INT2STRING"><b>int2string</b></a></td>
<td><a href="#INTERPTABLE"><b>interp_table</b></a></td>
<td><a href="#LIM"><b>lim</b></a></td>
<td><a href="#LIN"><b>lin</b></a></td>
<td><a href="#LINTRANS"><b>lintrans</b></a></td>
<td><a href="#LOCAL"><b>local</b></a></td>
<td><a href="#LOCK"><b>lock</b></a></td>
</tr>

<tr>
<td><a href="#LOG"><b>log</b></a></td>
<td><a href="#LOG10"><b>log10</b></a></td>
<td><a href="#LOOP"><b>loop</b></a></td>
<td><a href="#MAX"><b>max</b></a></td>
<td><a href="#MEAN"><b>mean</b></a></td>
<td><a href="#MESSAGE"><b>message</b></a></td>
<td><a href="#MESSAG1"><b>messag1</b></a></td>
</tr>

<tr>
<td><a href="#MIDICHORD"><b>midichord</b></a></td>
<td><a href="#MIDIECHO"><b>midiecho</b></a></td>
<td><a href="#MIDIIN"><b>midiin</b></a></td>
<td><a href="#MIDIOUT"><b>midiout</b></a></td>
<td><a href="#MIDISET"><b>midiset</b></a></td>
<td><a href="#MIN"><b>min</b></a></td>
<td><a href="#MOUSE"><b>mouse</b></a></td>
</tr>

<tr>
<td><a href="#MULT"><b>mult</b></a></td>
<td><a href="#MULTTABLE"><b>mult_table</b></a></td>
<td><a href="#NATLOG"><b>natlog</b></a></td>
<td><a href="#NUM2STRING"><b>num2string</b></a></td>
<td><a href="#OFFSETTABLE"><b>offset_table</b></a></td>
<td><a href="#PERM"><b>perm</b></a></td>
<td><a href="#PITCHBEND"><b>pitchbend</b></a></td>
</tr>

<tr>
<td><a href="#POP"><b>pop</b></a></td>
<td><a href="#POWER"><b>power</b></a></td>
<td><a href="#PRINT"><b>print</b></a></td>
<td><a href="#PROBE"><b>probe</b></a></td>
<td><a href="#PROBI"><b>probi</b></a></td>
<td><a href="#RAND"><b>rand</b></a></td>
<td><a href="#RANDOM"><b>random</b></a></td>
</tr>

<tr>
<td><a href="#RETURN"><b>return</b></a></td>
<td><a href="#ROUND"><b>round</b></a></td>
<td><a href="#SCALETABLE"><b>scale_table</b></a></td>
<td><a href="#SCHEDULE"><b>schedule</b></a></td>
<td><a href="#SEG"><b>seg</b></a></td>
<td><a href="#SHIFT"><b>shift</b></a></td>
<td><a href="#SHOWARGS"><b>showargs</b></a></td>
</tr>

<tr>
<td><a href="#SINE"><b>sine</b></a></td>
<td><a href="#SORT"><b>sort</b></a></td>
<td><a href="#SQRT"><b>sqrt</b></a></td>
<!--
<td><a href="#SPAWN"><b>spawn</b></a></td>
-->
<td><a href="#STOREDIGITS"><b>store_digits</b></a></td>
<td><a href="#STORE"><b>store</b></a></td>
<td><a href="#STORF"><b>storf</b></a></td>
</tr>

<tr>
<td><a href="#STORI"><b>stori</b></a></td>
<td><a href="#STOREFILE"><b>storefile</b></a></td>
<td><a href="#STORSTR"><b>storstr</b></a></td>
<td><a href="#SUBST"><b>subst</b></a></td>
<td><a href="#SUM"><b>sum</b></a></td>
<td><a href="#SUMTABLE"><b>sum_table</b></a></td>
<td><a href="#SWAP"><b>swap</b></a></td>
</tr>

<tr>
<td><a href="#TIME"><b>time</b></a></td>
<td><a href="#TRIGGER"><b>trigger</b></a></td>
<td><a href="#TRYRULE"><b>try</b></a></td>
<td><a href="#SWITCHON2"><b>switchon</b></a></td>
<td><a href="#SYSTEM"><b>system</b></a></td>
<td><a href="#TABLE"><b>table</b></a></td>
<td><a href="#TANGENT"><b>tangent</b></a></td>
</tr>

<tr>
<td><a href="#UNLOCK"><b>unlock</b></a></td>
<td><a href="#WAIT"><b>wait</b></a></td>
<td><a href="#WHILERULE"><b>while</b></a></td>
<td><a href="#XAD"><b>xad</b></a></td>
<td><a href="#XAR"><b>xar</b></a></td>
</tr>

</table>
</div>


<h2 id="ABS"><b>abs</b> &#150; Mathematical function</h2>

<blockquote>
<p>
Converts the argument to its 'absolute' (i.e. positive) value. Examples:
</p>

<blockquote>
<code><b>x = abs(x)</b></code> &#47;&#47;Force x to become positive
</blockquote>

<blockquote>
<code><b>y = abs(x)</b></code> &#47;&#47;Assign to y the positive value of x
</blockquote>

<blockquote>
<code><b>z = abs(x-3.7)</b></code> &#47;&#47;Assign to z the positive
value of (x-3.7)
</blockquote>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="ADDDEC"><b>add_dec</b> &#150; Rule</h2>

<blockquote>
<p>
Conditionally add or decrement a value to a cell. There are four
arguments: one output cell, and three input expressions, as follows:
</p>

<blockquote>
<code><b>out  add_dec   comp1, comp2, value</b></code>
</blockquote>

<ul>
<li>If 'comp1' is less than 'comp2', then 'value' is added to 'out'
<li>If 'comp2' is less than 'comp1', then 'value' is subtracted from 'out'
<li>If 'comp1' is equal to 'comp2' then no action is taken.
</ul>

<h3>
Rule Return Status:
</h3>

<p>
<b>1</b> if action has taken place, <b>0</b> if no action has been taken.
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="ALLLOCKED"><b>alllocked</b> &#150; Rule</h2>

<blockquote>
<p>
Test whether all of a list of cells are 'locked' (see 'lock' rule).
Should be used in conjunction with <b>try</b> (see 'try' rule).
</p>

<p>
Examples:
</p>

<blockquote>
<code><b>
probi try(alllocked  a, b, c, d)

<p>
if(try(alllocked a, b, c, d) {<br>
&nbsp;&nbsp;&nbsp;....<br>
}</b></code>
</p>
</blockquote>

<h3>
Rule Return Status:
</h3>

<p>
<b>1</b> if all cells are locked, <b>0</b> if one or more is unlocked.
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="ANYLOCKED"><b>anylocked</b> &#150; Rule</h2>

<blockquote>
<p>
Test whether any of a list of cells is 'locked' (see 'lock' rule).  Used
in conjunction with <b>try</b> (see 'try' rule).
</p>

<p>
Examples:
</p>

<blockquote>
<code><b>
probi try(anylocked  a, b, c, d)

<p>
if(try(anylocked a, b, c, d) {<br>
&nbsp;&nbsp;&nbsp;....<br>
}</b></code>
</p>
</blockquote>

<h3>
Rule Return Status:
</h3>

<p>
<b>1</b> if any cell is locked; <b>0</b> if none are locked.
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>

<h2 id=ARCCOSINE"><b>arccosine</b> &#150; Mathematical Function</h2>

<blockquote>
<p>
Also known as the 'inverse cosine'.
<p>
Example:
</p>
<blockquote>
<code><b>
a = arccosine(b)
</b></code>
</blockquote>
<p>
The input value to the function, b in the above example,
which is NOT checked, should be a value between -1 and +1.
The output will be a value between pi and zero.
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>

<h2 id=ARCSINE"><b>arcsine</b> &#150; Mathematical Function</h2>

<blockquote>
<p>
Also known as the 'inverse sine'.
<p>
Example:
</p>
<blockquote>
<code><b>
a = arcsine(b)
</b></code>
</blockquote>
<p>
The input value to the function, b in the above example,
which is NOT checked, should be a value between -1 and +1.
The output will be a value between -pi/2 and +pi/2.
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>

<h2 id="ARCTANGENT"><b>arctangent</b> &#150; Mathematical Function</h2>

<blockquote>
<p>
Also known as the 'inverse tangent'.
<p>
Example:
</p>
<blockquote>
<code><b>
a = arctangent(b)
</b></code>
</blockquote>
<p>
The input value to the function, b in the above example,
may be from -largevalue to +largevalue. However, values
below, say, -10 and above +10 will have decreasing effect.
The output will be a value between -pi/2 and +pi/2.
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="ARG"><b>arg</b> &#150; Mathematical function</h2>

<blockquote>
<p>
Employ a value passed from the commandline.  The number (n) of the
argument will correspond to the nth value on the commandline, after
the program name and the script name.
</p>

<p>
Example:
</p>

<blockquote>
[On commandline]:

<p>
<code><b>tv script 7.3 11 -3.05</b></code>
</p>

<p>
[Within the script]:
</p>

<p>
<code><b>
a = arg(1)<br>
b = arg(2)<br>
c = arg(3)<br>
</b></code>
</p>
</blockquote>

<p>
Result:
</p>

<p>
'a' will take the value 7.3; 'b' the value 11, and 'c' the value -3.05
</p>

<p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>

<h2 id="ARGC"><b>argc</b> &#150; Command line function</h2>
<blockquote>
<p>
This function (previously undocumented) tests whether the correct number of arguments have been supplied on the command line.  It is placed at the head of <b>initialise()</b>.  It is customary to show the Usage and end running the script if the number of arguments is insufficient.  The following example, which uses the ability (new in 1.5) of message to display a variable, illustrates this:

<blockquote>
<code><b>
  if(argc() < 5) {  &nbsp;&nbsp;&nbsp;&nbsp; //command line has less than 5 arguments <br>
    correctnumargs = 5 <br>
    message "\nInsufficient arguments on command line\n" <br>
    message << "\nYou should have ", int2string(correctnumargs), " arguments on the command line, otherwise the script will end or, better, show the Usage and end\n\n" >>
		<br>
    call usage() <br>
    end <br>
  }  <br>
</b></code>
</blockquote>
</p><p>
The script <b>argctest.tv</b> illustrates the use of the function.
</p>

</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>

<h2 id="ARGS"><b>args</b> &#150; Command line string function</h2>

<blockquote>
<p>
Pass a string (e.g. a filename) from the commandline.  The number (n) of the
argument will correspond to the nth string on the commandline, after
the program name and the script name. It is possible to use this
command line function with the script functions <b> storefile</b>, <b>storstr </b> and <b> fill_table</b>,
and to display the string arguments with <b>showargs</b>.
</p>

<p>
Example:
</p>

<blockquote>
[On commandline]:

<p>
<code><b>tv script file.txt</b></code>
</p>

<p>
[Within the script]:
</p>

<p>
<code><b>
storefile args(1)<br>
</b></code>
</p>
</blockquote>

<p>
Result:
</p>

<p>
The file named on the command line ('file.txt' in this case) will be used to store any data written from the script.
</p>

<p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="BREAK"><b>break</b> &#150; Control-flow</h2>

<blockquote>
<p>
Break out of a 'for' or 'while' loop,  with or without using a label.
Without a label, control flow passes to the rule-lines immediately
after the 'for' or 'while' loop in question.  If the break is to occur
across procedures (i.e., jumping out of one procedure and passing to
another) the label mechanism should be used.  A label is any convenient
name which is placed immediately after the 'for' or 'while' keywords in
order to identify them as the break location.  Control then passes to
the rule-lines immediately after the label, even if the label is in
another procedure.
</p>

<p>
Example:
</p>

<pre><code><blockquote>
[In procedure <b>a()</b>...]

<b>for wednesday (i = 0; i &lt; 7; i+=1) {
	if(x &gt; 32) {
	break
	&#47;&#47; breaks out of this for<b>()</b>loop
	} &#47;&#47; &shy; no label reference required
	....
}</b>

[In procedure <b>b()</b>...]

<b>if(t &gt; 10) {
	break wednesday
	&#47;&#47; break until after the 'wednesday'
	&#47;&#47; label in procedure <b>a()</b>
}</b>
</blockquote></code></pre>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="CALL"><b>call</b>&nbsp;&nbsp;Control-flow</h2>

<blockquote>
<p>
Call another procedure.  When a performance first starts, control will
be with the start() procedure.  At some point it may be desirable to
jump to another procedure. Suppose the user has named this second
procedure watery(). Then the rule-line to do so will take the form:
</p>

<blockquote>
<code><b>call watery()</b></code>
</blockquote>

<p>
Moving back to the originating procedure can be effected by the
<b>return</b> keyword  (q.v.).
</p>

<p>
Values may be passed to procedures by placing cell names or values
inside the parentheses of the procedure name. So
</p>

<blockquote>
<code><b>call watery(15.7)</b></code>
</blockquote>

<p>
will mean that the value 15.7 is passed to the procedure 'watery()'.
</p>

<blockquote>
<code><b>call watery(x)</b></code>
</blockquote>

<p>
will mean that the present value of 'x' in the originating procedure
will  be passed  to the procedure 'watery()'.  The receiving procedure
'watery()' may then assign a cell name, which in this instance will
be local,  to the  value inherited from the originating procedure,
by giving it a new name. E.g.:
</p>

<pre><code><blockquote><b>
watery(qq)
{
     if(qq &lt; time_passed) {
          ..... [etc]
</b></blockquote></code></pre>

<p>
In this case the cell local to the procedure 'watery()' is called
'qq' and is assigned the value inherited from the call in the
originating  procedure  (in the examples above, either 15.7 or 'x').
</p>

<p>Note that multiple values may be passed, if required, as shown in
the following short script:

<pre><code><blockquote><b>
start()
{
        x = 9.3
        y = 77
        call proc1(x, 5, y)
}

proc1(f, g, h)
{
        probe f, g, h
}
</b></blockquote></code></pre>

<p>
It is also possible to employ a label immediately after <b>call</b>, as in:
</p>

<blockquote>
<code><b>call saturn watery()</b></code>
</blockquote>

<p>
In this case the label ('saturn') may be used by a later procedure to
return to this location.  More than one call may use the same label
&#150; there is no conflict as the most recent label is used .
(See Manual entry for <b>return</b>.)
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>

<h2 id="CLOSE_STOREFILES"><b>close_storefiles</b> &#150; Control-flow</h2>

<blockquote>
<p>
Close (all) open storefiles. This function may be used if the user wishes
to re-use previously-written data later in a script. When a storefile is
closed, data from the file may be used again by accessing it with 'fill_table'.
The following script shows this process in embryo:
<pre><code><blockquote><b>
// 'numbers.tv' - show the use of 'close_storefiles'
table NUMBERS[4]

start()
{
	storefile "numbers.txt"
	for(i=0;i&lt;dimsize(NUMBERS, 1); i+=1) {
		NUMBERS[i] = int(random(3, 17))
	}
	message "Table of 4 Numbers is "
	for(i=0; i&lt;dimsize(NUMBERS, 1); i+=1) {
		print NUMBERS[i], 5, 0
		stori NUMBERS[i]
		storstr "\t"
	}
	message "\nNow closing storefile 'numbers.txt'.\n"
	close_storefiles
	NUMBERS fill_table "numbers.txt"
	perm NUMBERS
	message "Numbers have been read in again from the closed file,"
	message " and scrambled:\n\tthe order is now "
	for(i=0; i&lt;dimsize(NUMBERS, 1); i+=1) {
		print NUMBERS[i], 5, 0
	}
}
</b></blockquote></code></pre>

</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="CLS"><b>cls</b> &#150; Control-flow</h2>

<blockquote>
<p>
Clears the screen.  Allows the user to remove previous message, print
and probe data from the screen, either at the beginning of a
performance, or even during performance.
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="COMPARE"><b>compare</b> &#150; Rule</h2>

<blockquote>
<p>
Prototype script line:
</p>

<blockquote>
<code><b>C compare A, B [,typeflag]</b></code>
</blockquote>

<p>
This rule compares two input tables, and writes into an output table
either the values which are common to both, or values which appear in
one input table only.  If 'typeflag' is zero or is omitted,  then the
output table will put into the output table those values which are
common to both tables.  If 'typeflag' is non-zero, then the exclusive
option will operate.
</p>

<p>
Suppose we have the following four tables:
</p>

	<blockquote>
	<b>A[8]</b> contains the following MIDI notes:<br>
        &nbsp;&nbsp;<b>62 65 70 71 72 63 66 67</b>
	<p>
	while table<br>
	<b>B[9]</b> contains the following MIDI notes:<br>
        &nbsp;&nbsp;<b>71 72 63 66 67 64 68 69 73</b>
	</p>
	<p>
	<b>C[5]</b> and <b>D[7]</b> have been declared but not yet initialised.
     	</p>
	</blockquote>
<p>
After the following script line:
</p>

<blockquote>
<code><b>C compare A, B, 0</b></code><br>
&nbsp;&nbsp;or<br>
<code><b>C compare A, B</b></code>
</blockquote>

<p>
then table <b>C</b> will contain<br>
&nbsp;&nbsp;<b>71 72 63 66 67</b>
</p>

<p>
because 'typeflag' is <b>0</b>, meaning inclusive.
</p>

<p>However, with 'typeflag' set to <b>1</b> &#150; meaning exclusive
&#150 as in:
</p>

<blockquote>
<code><b>D compare A, B, 1</b></code>
</blockquote>

<p>
then table <b>D</b> will contain<br>
&nbsp;&nbsp;<b>62 65 70 64 68 69 73</b>
</p>

<p>
which are the numbers appearing in either table but not in both.
</p>

<h3>
Rule Return Status:
</h3>

<p>
<b>1</b> after the first and only action; thereafter <b>0</b>
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="CONTINUE"><b>continue</b> &#150; Control-flow</h2>

<blockquote>
<p>
Continue with a <b>for()</b> or <b>while()</b> loop, with or without
using a label.  Without a label, control flow continues with the local
<b>for</b> or <b>while</b>.  A label is any convenient name which is
placed immediately after the <b>for</b> or <b>while</b> keywords in order
to identify them as the location for continue.  Labels should be used
if continue calls are made across procedure boundaries.
</p>

<p>
Example:
</p>

<pre><code><blockquote><b>
     [In procedure a()...]
for thursday (i = 0; i &lt; 7; i+=1) {
     if(i &lt; 4 || i &gt; 4) {
          continue       // continues with this for() loop
     }                   // - no label reference required
     ....
}

     [In procedure b()...]

if(t &gt; 10) {
     continue thursday   // continue with the 'thursday'
                         // label in procedure a()
}
</b></blockquote></code></pre>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="CONTROLOUT"><b>control_out</b> &#150; Rule</h2>

<blockquote>
<p>
Send a MIDI control message.  There are three input cells: 'Channel'
(0 -  15), 'Control-Number', and 'Value', respectively.   The following
example script uses <b>control_out</b> to continuously vary the volume of
two MIDI channels:

<pre><code><blockquote><b>
start()
{
        if(first == 0) {
            midiset 0, 71
            midiset 1, 71
	volume = 7
            dur = 0.5
            pch = 60
	first = 1
        }

        if(try(midiout 0, pch, 100, dur, 1) &gt; 0) {
            crdur1 = random(0.15, 0.45)
            pch = random(48, 72)
        }
        if(try(midiout 1, pch+1, 100, dur, 1) &gt; 0) {
            crdur2 = random(0.15, 0.8)
        }
        dur = random(0.4, 2.0)
        a       lin     crdur1, 0, 110, 60
        b       lin     crdur2, 1, 110, 60
        control_out     0, volume, a
        control_out     1, volume, b
loop
}
</b></blockquote></code></pre>

<h3>
Rule Return Status:
</h3>

<p>
Always <b>1</b>
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="COPY"><b>copy</b> &#150; Rule</h2>

<blockquote>
<p>
Copies the value of an input cell into one or more output cells. Example:
</p>

<blockquote>
<code><b>a, b, c copy x</b></code>
</blockquote>

<p>
will copy the value of 'x' into a, b, and c.
</p>

<p>
Table pointers can also be assigned with copy, as in:
</p>

<blockquote>
<code><b>A, B copy C</b></code>
</blockquote>

<p>
<b>NB</b> Since <b>copy</b> is a rule, it should always be employed
instead of assignments where cell-locking or unlocking is being
employed.  Mathematical assignments (of the type 'a = 5.6') will always
override cell-locking.
</p>

<h3>
Rule Return Status:
</h3>

<p>
<b>1</b> if copy has succeeded<br>
<b>0</b> if one or more copies has failed (e.g. if a cell has been locked).
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="COPYTABLE"><b>copy_table</b> &#150; Rule</h2>

<blockquote>
<p>
Copies the contents of one table to another.  If the tables are of
different sizes, then only values to the extent of the smaller-size
table will be copied.  For example,
</p>

<blockquote>
<code><b>BBB copy_table AAA</b></code>
</blockquote>

<p>
will copy the  contents of table <b>AAA</b> to table <b>BBB</b>, and
</p>

<blockquote>
<code><b>
'TEXTLIST copy_table 'SFILELIST
</b></code>
</blockquote>

<p>
will copy the contents of string table <b>'SFILELIST</b> to the string table <b>'TEXTLIST</b>.
</p>
<h3>
Rule Return Status:
</h3>

<p>
<b>1</b> if copy_table has succeeded in full<br>
<b>0</b> if the tables were of different sizes
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="COSINE"><b>cosine</b> &#150; Mathematical Function</h2>

<blockquote>
<p>
Give the cosine of a value in radians;  the output will thus always be a
value between -1.0 and +1.0.
</p>

<p>
Examples:
</p>

<blockquote>
<code><b>a = cosine(2.17)<br>
a = cosine(b)</b></code>
</blockquote>

<p>
Places the cosine of the input cell 'b' into cell 'a'.
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>

<h2 id="DIMENSIONS"><b>dimensions</b> &#150; Mathematical Function</h2>

<blockquote>
<p>
Return the number of dimensions of a table
</p>

<pre><code><blockquote><b>
// Script example:
table TAB[10][5][2]

start() {
        probi dimensions(TAB)
}
</b></blockquote></code></pre>

<p>
The script will print the number '3' to the console.
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>

<h2 id="DIMSIZE"><b>dimsize</b> &#150; Mathematical Function</h2>

<blockquote>
<p>
Return the number of cells in a table dimension.  There are two
required arguments to <b>dimsize</b>: the table name (or table
pointer-name) and the number of the dimension about which information
is required.   If, for example, a table has been declared
</p>

<blockquote>
<code><b>table AAA[8]</b></code>
</blockquote>

<p>
at the head of the script, then
</p>

<blockquote>
<code><b>x = dimsize(AAA, 1)</b></code>
</blockquote>

<p>
will assign the value 8 to 'x'.
</p>

<p>
Note that <b>dimsize</b> is an acceptable argument for the <b>int2string()</b> and <b>num2string()</b> functions (from Version 1.5), as in:
</p>
<blockquote> 
<code><b>int2string(dimsize('SFILELIST, 1))</b></code>
</blockquote>
<p>
when used in a <b>message</b> or <b>messag1</b> statement.
</p><p>
<b>dimsize</b> can also be used with string tables in FOR loops to determine the end point of the loop:
</p>
<blockquote>
<code><b>for(i = 0; i <= dimsize('SFILELIST, 1); i += 1) { </b></code>
</blockquote>

</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="EMBED"><b>embed</b> &#150; Rule</h2>

<blockquote>
<p>
Embed two one-dimensional tables. The form of the rule is:
</p>

<blockquote>
<code><b>C embed A, B</b></code>
</blockquote>

<p>
The size of output table <b>C</b> should optimally be the sizes of
input tables <b>A</b> and <b>B</b> multiplied together. (If smaller,
embedding will be incomplete; if larger, the last table values will
contain zeroes.)  The data in the input tables should be equivalent,
but the values in table <b>B</b> are made relative and then used to
offset (by addition, <b>NB</b>) in turn each value in table <b>A</b>
to create the output table <b>C</b>.  While the rule runs in
performance time, once the output table has been created it
thereafter has no effect, even if values in the input tables change.
</p>

<h3>Rule Return Status:
</h3>

<p>
<b>1</b> after the first and only action; thereafter <b>0</b>
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="END"><b>end</b> &#150; Control-flow</h2>

<blockquote>
<p>
Ends performance.  Under normal usage, the performance of <i>Tabula
Vigilans</i> will continue until the user presses a key on the
console.  However, <b>end</b> is incorporated for use in those
circumstances where it is desired that the performance end when a
cell has reached a certain value. Example:
</p>

<pre><code><blockquote><b>
if(t &gt;= 180.00) {
     end
}
</b></blockquote></code></pre>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="EXP"><b>exp</b> &#150; Rule</h2>

<blockquote>
<p>
<b>exp</b> creates an exponential time-varying output moving between
a minimum and a maximum value.
</p>

<p>
The prototype of the rule is:
</p>

<blockquote>
<b><code>out  exp  dur, [, direction [, scale_value1,
scale_value2]]</b></code>

<p>
'out' is the current value of the output<br>
'dur' is the duration over which <b>exp</b> creates the exponential
time-varying value<br>
['direction'] &#150; optional &#150; is the starting direction:<br>
&nbsp;&nbsp;&nbsp;<b>0</b> (default) moves first from minimum to maximum<br>
&nbsp;&nbsp;&nbsp;<b>1</b> causes the first movement to be from maximum
to minimum
</p>
</blockquote>

<p>
<b>NB</b> Direction will be applied whichever order the values appear in
'scale_value1' and 'scale_value2'.
</p>

<p>'scale_value1' and 'scale_value2' are the values to be supplied for
the minimum and maximum.  If these are omitted, minimum is <b>0</b>,
maximum is <b>1</b>.
</p>

<h3>
Rule Return Status:
</h3>

<p>
<b>1</b> at the end of each exponential segment reached<br>
<b>0</b> on every other occasion
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="FAIL"><b>fail</b> &#150; Rule</h2>

<blockquote>
<p>
This rule is used for testing and debugging.
</p>

<h3>
Rule Return Status:
</h3>

<p>
Always <b>0</b>
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="FILLTABLE"><b>fill_table</b> &#150; Rule</h2>

<blockquote>
<p>
Fill a table from a textfile. <br>The table will previously have been declared at the head of the script and may be sized (e.g. TABLE[6]) or unsized (e.g. TABLE[]).<br>
Fill_table may be used to fill a numerical or string table (the latter denoted by a prefixed <b>'</b> character). 
</p><p>
Example:
</p>

<blockquote>
<code><b>AAA fill_table "pitches" [, pos]</b></code>
</blockquote>

<p>
In this case table 'AAA' will be filled with values from a text file
named "pitches" which is assumed to be in the current working directory.
Unless filling a string table, the file should contain integer or floating-point values, separated by
white space (i.e., spaces, tabs or carriage returns).  Comments may
be inserted after the double slash character &#47;&#47.  If there are
more values in the file than there are cells in the table, then only
the first values to the size of the table will be read;  if there are
not enough values to fill the table, then the remainder of the table
will contain zeros.
</p>

<p>
If the optional argument 'pos' is used, then this will be taken as
the starting number.  If 'pos' is <b>0</b> or <b>1</b>, then
<b>fill_table</b> will read from the beginning of the file;  this is
the default condition.  If 'pos' is any number greater than <b>1</b>,
then the rule will begin the fill from that position.
</p>

<blockquote>
<code><b>AAA fill_table "intervals", 19</b></code>
</blockquote>

<p>
This example will fill table <b>AAA</b> starting with the 19th value in
'intervals'.
</p>

<blockquote>
<code><b>'SFILELIST fill_table "sndlist.txt"</b></code>
</blockquote>

<p>
In this case, a table of strings (text) is filled from a list of strings in a text file.  Note that the text file should end on the final line and not put a carriage return after the final item.  Otherwise, a blank item may appear when using the string table.  Only single-dimension string tables are valid.
</p>
<p>
Currently there is no way to test the return status of <b>fill_table</b>.
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="FOLD"><b>fold</b> &#150; Rule</h2>

<blockquote>
<p>
Time-based (multiplicative) embedding of one-dimensional tables.  The
form of the rule is:
</p>

<blockquote>
<code><b>C fold A, B</b></code>
</blockquote>

<p>
The output table 'C' will hold the values of table 'B' folded into
table 'A' (compare rule <b>embed</b>).  The data in the input tables
are regarded as equivalent, but those in table 'A' are absolute (in
seconds),  those in table 'B' are relative,  used to scale by
multiplication the successive values of table 'A'.  The size of the
output table should be the sizes of the input tables multiplied
together. While the rule runs in performance time, once the output
table has been created it thereafter has no effect, even if values
in the input tables change.
</p>

<h3>
Rule Return Status:
</h3>

<p>
<b>1</b> after the first and only action;  thereafter <b>0</b>.
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="FORRULE"><b>for</b> &#150; Control-flow</h2>

<blockquote>
<p>
Set up a loop counter, of the form:
</p>

<pre><code><blockquote><b>
for(i = 0; i &lt; 12; i+=1) {
     A[i] = i+1
}
</b></blockquote></code></pre>

<p>
This simple example will set up a table 'A' with numbers 1 &#150; 12 in
it.  However, the for loop, bounded by braces, may contain indefinitely
many rule-lines.
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="GAMMA"><b>gamma</b> &#150; Mathematical Function</h2>

<blockquote>
<p>
Prototype:
</p>

<blockquote>
<code><b>g = gamma()</b></code>
</blockquote>

<p>
The result is a random number lying between <b>0</b> and <b>1</b>,
exhibiting Gamma Probability Distribution characteristics.  The
statistical weighting is biased to the first half of the range,
with a curve as shown below:
</p>

<p>
<blockquote>
<img src="gamma.gif" ALT="Gamma distribution curve">
</blockquote>
</p>

</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="GAUSS"><b>gauss</b> &#150; Mathematical Function</h2>

<blockquote>
<p>
Prototype:
</p>

<blockquote>
<code><b>g = gauss()</b></code>
</blockquote>

<p>
The result is a random number lying between <b>0</b> and <b>1</b>,
exhibiting Gaussian Probability Distribution characteristics.  The
statistical weighting is biased to the middle of the range, with a
curve as shown below:
</p>

<p>
<blockquote>
<img src="gauss.gif" ALT="Gaussian distribution curve">
</blockquote>
</p>

</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="GENERATE"><b>generate</b> &#150; Rule</h2>

<blockquote>
<p>
Prototype:
</p>

<blockquote>
<code><b>BBB generate AAA</b></code>
</blockquote>

<p>
This rule is designed to generate a first-order set of values in the
output table by extracting adjacent intervals from an input table and
in turn incrementing and decrementing them from each member of the input
table.  The output table is sorted in ascending order, and if the size
of the output table differs from the optimum, the user is advised.
</p>

<h3>
Rule Return Status:
</h3>

<p>
<b>1</b> after the first and only action; thereafter <b>0</b>
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>

<h2 id="IF2"><b>if</b> &#150; Control-flow</h2>

<blockquote>
<p>
Conditional branch, with or without the <b>else</b> construct.  The
following syntax for the rule-file is required:
</p>

<pre><code><blockquote><b>
if(expression relation  expression) {
     ...other rule-lines...
     ...other rule-lines...
     ...other rule-lines...
}
</b></blockquote></code></pre>

<p>
The relation between the expressions should be one of the following:
</p>

<table border=3 cellpadding=4>
<caption><b>Expression Relationships</b></caption>
<tr>
<td><b>&lt;</b></td>        <td>less than</td>
</tr>

<tr>
<td><b>&gt;</b></td>        <td>greater than</td>
</tr>

<tr>
<td><b>==</b></td>          <td>is equal to</td>
</tr>

<tr>
<td><b>!=</b></td>          <td>is NOT equal to</td>
</tr>

<tr>
<td><b>&lt;=</b></td>       <td>is less than or equal to</td>
</tr>

<tr>
<td><b>&gt;=</b></td>       <td>is greater than or equal to</td>
</tr>

<tr>
<td><b>&amp;&amp;</b></td>  <td>logical AND</td>
</tr>

<tr>
<td><b>&#124;&#124;</b></td> <td>logical OR</td>
</tr>
</table>

<p>
The following are examples of valid <b>if</b> clauses:
</p>
<blockquote>
<code><b>if(a == b)
<p>
if((a &gt;= 3) &amp;&amp; (b &gt; a))
</p>
<p>
if(a*7 &lt; b^0.3)</b></code>
</p>
</blockquote>

<p>
<b>else</b> may follow the 'if', in the following manner:
</p>

<pre><code><blockquote><b>
if(a &gt;= 100) {
     b =  a % 7
} else {
     b = a % 3
}
</b></blockquote></code></pre>

</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>

<h2 id="INCLUDE2"><b>#include</b> &#150; Initialisation</h2>

<blockquote>
<p>
Incorporate another tv script within the present script.
</p>

<blockquote>
Example:
</blockquote>

<blockquote>
[At the beginning of the current script:]
<p>
<code>#include "otherfuncs.tv"</code>
</p>
</blockquote>

</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="INT"><b>int</b> &#150; Mathematical Function</h2>

<blockquote>
<p>
Return the integer value of a number (i.e the integer next lower than
the number). Examples:
</p>

<blockquote>
<code><b>x = int(77.35)</b></code>
</blockquote>

<p>
will assign the value 77.00 to x, and
</p>

<blockquote>
<code><b>a = 55.32<br>
b = int(a)</b></code>
</blockquote>

<p>
will assign the value 55.00 to b.
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="INT2STRING"><b>int2string</b> &#150; Type-conversion Function</h2>
<blockquote>
<p>
Converts an integer to a string.
</p><p>
Examples:
</p><p>
<blockquote>
<code><b>
int2string(12)
<br>
int2string(int_variable) 
</b></code>
</blockquote>
</p><p>
The function enables an integer value to be displayed by <b>message</b> &#47; <b>messag1</b> or stored by <b>storstr</b>, using their second format in which one or more strings are enclosed within double-chevrons &lt;&lt; &nbsp; &gt;&gt;. (See message or storstr for an example.)
 
</p><p>
The converted string cannot be assigned to a variable or an element of a string table. Thus the following will give syntax errors:
  <blockquote>
  <code><b>
  a = int2string(60)
  <br>
  'STRTABLE[0] = int2string(60)
  </b></code>
  </blockquote>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="INTERPTABLE"><b>interp_table</b> &#150; Rule</h2>

<blockquote>
<p>
This rule interpolates a value between each corresponding value in two tables, and writes the result into a result table.  An example rule-line is given below:
</p>

<blockquote>
<code><b>A interp_table B, C, 0.3</b></code>
</blockquote>

<p>
This means that each cell value in table <b>A</b> is calculated from
the same index value of table <b>C</b> multiplied by 0.3, plus the
same index value of table B multiplied by (1.0 - 0.3), or 0.7.  If
the rightmost input is itself a cell, when iterated while varying
this value between <b>0</b> and <b>1</b> will result in a series of
interpolated tables that move from table <b>B</b> to table <b>C</b>.
Only the fractional part of the value of the right-most cell is taken
as the rule argument.  If tables of different sizes are given to the
rule, then only the outputs corresponding to the smallest-size table
are calculated.
</p><p>
Note &#150; this rule does not apply to string tables.
</p>

<h3>Rule Return Status:
</h3>

<p>
Always <b>1</b>
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="LIM"><b>lim</b> &#150; Rule</h2>

<blockquote>
<p>
Constrain a cell to lie within given limits.
</p>

<p>
<b>lim</b> has one output cell, and two inputs:  'limit-low' and
'limit-high'.  The rule takes the form:
</p>

<pre><code><blockquote><b>
// limit cell 'a' to lie between limits
a    lim  -1.0, 1.0
a    lim  b, c
</b></blockquote></code></pre>

<p>
In the first of these, the meaning is that the value of cell 'a' is
constrained  to lie within  the limits -1 to  +1.  In  the second, 'a'
is constrained  to lie between the limits denoted by the values
within cells  'b' and  'c'.  The convention is that the values after
the opname are 'low  limit' and 'high limit' respectively, but in
practice it does not matter - after all, the values within named input
cells may change dynamically and 'cross over' by design.  In either
case, if the value in output cell 'a' lies  outside the delimitation
zone, it will be amended to the limiting value.
</p>

<h3>
Rule Return Status:
</h3>

<p>
<b>&nbsp;1</b> if the limiting operation has succeeded<br>
<b>-1</b> if the operation has failed (because the output cell is locked)<br>
<b>&nbsp;0</b> if no action has been taken (because the output cell lies
within limits).
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="LIN"><b>lin</b> &#150; Rule</h2>

<blockquote>
<p>
<b>lin</b> creates a linear time-varying output (i.e., moving between
a minimum and a maximum value). The prototype of the rule is:
</p>

<blockquote>
<code><b>out lin dur, [, direction [, scale_value1, scale_value2]]</b></code>
<p>
'out' is the current value of the output<br>
'dur' is the duration over which lin creates a linear time-varying value
</p>
<p>
['direction'] - optional - is the starting direction:<br>
&nbsp;&nbsp;&nbsp; <b>0</b> [default] moves first from minimum to maximum<br>
&nbsp;&nbsp;&nbsp; <b>1</b> causes the first segment to move from maximum
to minimum
</p>
<p>
[scale_value1 &amp; scale-value2] are the values to be supplied as
minimum and maximum respectively.  If omitted, minimum is <b>0</b>,
maximum is <b>1</b>.
</p>
</blockquote>

<h3>
Rule Return Status:
</h3>

<p>
<b>1</b> when lin is first called, and thereafter as the end of each
linear segment has been reached.<br>
<b>0</b> at each other occasion.
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="LINTRANS"><b>lintrans</b> &#150; Rule</h2>

<blockquote>
<p>
Implements a combined multiply and add in a single operation &#150; a
linear transformation of the type a = b * c + d.  There is one output
cell, and three input arguments. The prototype rule is:
</p>

<blockquote>
<code><b>result lintrans input, multiply_value, add_value</b></code>
</blockquote>

<p>
or, using the same identifiers as in the equation above:
</p>
<blockquote>
<code><b>a lintrans  b, c, d</b></code>
</blockquote>

<p>
Example:
</p>
<blockquote>
<code><b>a lintrans  b, 2.3, 1.7</b></code>
</blockquote>

<p>
If the output cell is identical to the input cell, the linear
transformations will of course be incremental:
</p>
<blockquote>
<code><b>a lintrans a, 2.3, 1.7</b></code>
</blockquote>

<h3>
Rule Return Status:
</h3>

<p>
<b>1</b> if the lintrans operation has succeeded<br>
<b>0</b> if the output cell is locked
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="LOCAL"><b>local</b> &#150; Control-flow</h2>

<blockquote>
<p>
Declare a cell to be local (private) to the current procedure.  This has
the  effect  that  the  same name can be used in other procedures with
no conflict.  Note that when a parameter is passed from one procedure
to another, the cell receiving the parameter value is always local in scope.
</p>

<p>
Example:
</p>

<pre><code><blockquote><b>
solar()
{
    local sun  // the cell 'sun' is private to the procedure 'solar'
        ...
}
</b></blockquote></code></pre>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>

<!-- end of tvm4ae.htm -->
<!-- start of tvm5ae.htm -->

<h2 id="LOCK"><b>lock</b> &#150; Rule</h2>

<blockquote>
<p>
Lock one or more cells.
</p>
<p>
All cells by definition contain values which may be treated as variables,
i.e., they may be changed dynamically within the performance loop.  However,
there may arise occasions when the user does not wish the variable to be
changed.  In such cases the user may lock the variable against change, in
effect making it a constant for the duration of the lock.  (There is a
complementary rule <b>unlock</b> which  unlocks the cell again, and cells
may be locked and unlocked at will during different segments of the
performance loop.)  A cell being locked  will often change the meaning of
a rule:  examples of this are given in this Manual for <b>lim</b> and
<b>sum</b>. Example rule-line:
</p>

<blockquote>
<code><b>lock a, b &#47;&#47; lock cells 'a' and 'b'</b></code>
</blockquote>

<p>
It is important to understand that <i>rules will only obey rules</i>.
Assignments will always over-rule rules.  In the following block:
</p>

<pre><code><blockquote><b>
...
a = 136
lock a
a copy 245
...
</b></code></blockquote></pre>

<p>
since <b>copy</b> is a rule, it will obey the lock, and at the end of
this block, 'a' will still equal 136.  However, after the following:
</p>

<pre><code><blockquote><b>
...
a = 136
lock a
a = 245
...
</b></code></blockquote></pre>

<p>
'a' will now equal 245, because the assignment operator '=' has
overruled the rule 'lock'.
</p>

<h3>
Rule Return Status:
</h3>

<p>
Always <b>1</b>
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="LOG"><b>log</b> &#150; Rule</h2>

<blockquote>
<p>
<b>log</b> creates a logarithmic time-varying output moving between a
minimum and a maximum value.
</p>

<p>
The prototype of the rule is:
</p>
<blockquote>
<code><b>out log  dur, [, direction [, scale_value1, scale_value2]]</b></code>

<p>
'out' is the current value of the output<br>
'dur' is the duration over which <b>log</b> creates the logarithmic
time-varying value.
</p>

<p>
['direction'] - optional - is the starting direction:<br>
&nbsp;&nbsp;&nbsp;<b>0</b> (default) moves first from minimum to maximum<br>
&nbsp;&nbsp;&nbsp;<b>1</b> causes the first movement to be from maximum
to minimum
</p>

<p>
<b>NB</b> 'Direction' will be applied whichever order the values
appear in scale_value1 and scale_value2.
</p>

<p>
'scale_value1' and 'scale_value2' are the values to be supplied for the minimum and maximum. If these are omitted, minimum is 0, maximum is 1.
</p>
</blockquote>

<h3>
Rule Return Status:
</h3>

<p>
<b>1</b> at the end of each logarithmic segment reached<br>
<b>0</b> on every other occasion.
</p>

</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>

<h2 id="LOG10"><b>log10</b> &#150; Mathematical function</h2>

<blockquote>
<p>
Gives the logarithm, base 10, of any number.
<p>
Example:
</p>
<blockquote>
<code><b>
a = log10(b)
</b></code>
</blockquote>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="LOOP"><b>loop</b> &#150; Control-flow</h2>

<blockquote>
<p>
Return control-flow to the start of the current procedure.
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>

<h2 id="MAX"><b>max</b></a> &#150; Rule</h2>

<blockquote>
<p>
Place in the output cell the maximum value of a number of input arguments.
</p>

<p>
Example:
</p>

<blockquote>
<code><b>a max b, c, d, e</b></code>
</blockquote>

<p>
If a cumulative result &#150; over many iterations of a performance
loop &#150; is required, include the output cell in the input cell
list, as in the following:
</p>

<blockquote>
<code><b>a max a, b, c, d, e</b></code>
</blockquote>

<h3>
Rule Return Status:
</h3>

<p>
<b>1</b> under normal conditions<br>
<b>0</b> if the output cell is locked
</p>

</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="MEAN"><b>mean</b> &#150; Rule</h2>

<blockquote>
<p>
Place in the output cell the average, or mean, of a number of inputs arguments.
</p>

<p>
Example:
</p>

<blockquote>
<code><b>a mean b, c, d, e</b></code>
</blockquote>

<p>
The output cell 'a' stores the mean value of input cells b, c, d, e [....etc.].
</p>

<h3>
Rule Return Status:
</h3>

<p>
<b>1</b> if the mean operation has been carried out successfully<br>
<b>0</b> if the output cell is locked
</p>

</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>

<h2 id="MESSAGE"><b>message</b> &#150; Rule<br>
<a name="MESSAG1"><b>messag1</b></a> &#150; Rule
</h2>

<blockquote>
<p>
Output to the console a single message string in one of two formats. 
</p>

<p>
Example (Format 1):
</p>
<blockquote>
<code><b>message "This will be printed to the console"<br>
messag1 "This will be printed only once"</b></code>
</blockquote>

<p>
These rules will output a message on the monitor during performance.
For Format 1, the message to be displayed is placed within double quotation
marks, but the latter will not be shown.  The following special
characters may be used within the string to produce the desired format:
<blockquote>
<code><b>&#92;n (Newline)<br>
&#92;t (Tab)<br>
&#92;r (Return [to the beginning of the line, without Newline])</b></code>
</blockquote>

<p>
<b>message</b> will iterate the message as many times as it is called.<br>
<b>messag1</b> will print the message only the first time it is called.
</p>
<p>
From Version 1.5, it is now possible to contain multiple expressions, including variables, in the same message.  The overall format is << ... , ... >>: string items separated with commas and placed within a container of double-chevrons.
</p><p>
Text including \n and \t is contained in double quotes in the usual way: "\n" and "\t", and "\nSome text" and "some text\n" continue to be valid (i.e., newlines included in the same quotes as the text string). 
</p><p>
Example (Format 2):
</p>

<blockquote>
<code></b>
intvar = 60  <br>
floatvar = 261.63  <br>
messag1 << "\nINTEGER VARIABLE: ", int2string(intvar), "\t", "FLOAT VARIABLE: ", num2string{floatvar), "\n\n" >>  <br>
</b></code>
</blockquote>
<p>
which displays:
</p>
<blockquote>
<code><b>
INTEGER VARIABLE: 60	FLOAT VARIABLE: 261.63 
</b></code> (along with the specified tabs and newlines).
</blockquote>

<h3>
Rule Return Status:
</h3>

<p>
<b>message</b> Always <b>1</b><br>
<b>messag1</b> <b>1</b> when the message has just been printed to the
console, <b>0</b> thereafter.
</p>

</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>


<h2 id="MIDICHORD"><b>midichord</b> &#150; Rule</h2>

<blockquote>
<p>
This rule outputs a chord to the designated MIDI channel.  Its prototype is:
</p>

<pre><code><blockquote><b>
midichord chan, CHORD, vel, dur [, num_notes [, arp]]
</b></blockquote></code></pre>

<blockquote>
'chan' is the MIDI channel [0 - 15] on which the chord will be played<br>
'CHORD' is the name of the TABLE which contains the notes of the chord<br>
'vel' is the velocity of the notes, and<br>
'dur' the duration of the chord

<p>
The number of notes can be altered by designating 'numnotes' &#150;
the default is 1.
</p>

<p>
'arp' is a flag to determine whether the chord should be arpeggiated:<br>
&nbsp;&nbsp;&nbsp; <b>1</b> = arpeggiate (over dur &#47; num_notes)<br>
&nbsp;&nbsp;&nbsp; <b>0</b> = no arpeggiation
</p>
</blockquote>

<p>
<b>NB</b> If the user needs to change the direction of arpeggiation,
then a <b>sort</b> on the pitch table may be used prior to this rule.
</p>

<h3>
Rule Return Status:
</h3>

<p>
Positive number of notes immediately after launch<br>
Negative number of notes thereafter, until dur has elapsed
</p>

</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>

<h2 id="MIDIECHO"><b>midiecho</b> &#150; Rule</h2>

<blockquote>
<p>
Output immediately (echo) a MIDI event.  There are only three input
parameters: Channel [0 - 15], MIDI note and Velocity.
</p>

<p>
Example:
</p>

<blockquote>
<code><b>midiecho 0, 60, 80</b></code>
</blockquote>

<p>
This will output middle 'C' on MIDI Channel 0 (i.e., synthesizer
Channel 1!).  Note that no duration value is given, so it is up to
the user to turn off the note after the required duration by a matching
command at some  later  time, e.g.
</p>

<blockquote>
<code><b>midiecho 0, 60, 0</b></code>
</blockquote>

<p>
The rule may be most useful when immediately responding to a <b>midiin</b>
message, as in the following example:
</p>

<pre><code><blockquote><b>
start()
{
     c, n, v   midiin
               midiecho  c, n, v
loop
}
</b></blockquote></code></pre>

<p>
In this case the duration precisely matches that of the performed
<b>midiin</b> rule.  When you wish to output MIDI notes of a
score-specified duration, use <b>midiout</b> (see below).
</p>

<h3>
Rule Return Status:
</h3>

<p>
Always <b>1</b>
</p>

</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>

<h2 id="MIDIIN"><b>midiin</b> &#150; Rule</h2>

<blockquote>
<p>
If MIDI input data is available, <b>midiin</b> will collect it and
store it in its output cells, of which there are three.  The first
is the MIDI Channel (0  to 15), the second and third differ according
to the returned event type.
</p>

<p>
Example:
</p>

<blockquote>
<code><b>channel, data1, data2  midiin</b></code>
</blockquote>

<h3>
Rule Return Status:
</h3>

<div align=center>
<table border=3 cellpadding=4>
<caption><b>MIDIIN Data</b></caption>

<tr>
	<td><b>0</b></td>
	<td>No MIDI data available</td>
	<td><br></td>
	<td><br></td>
</tr>

<tr>
	<td><b>1</b></td>
	<td>Note Event:</td>
	<td>data1 = pitch</td>
	<td>data2 = velocity</td>
</tr>

<tr>
	<td><b>2</b></td>
	<td>Pitchbend Event:</td>
	<td>data1 = msb( low-res)</td>
	<td>data2 = lsb(hi-res)</td>
</tr>

<tr>
	<td><b>3</b></td>
	<td>Aftertouch Event:</td>
	<td>data1 = channel pressure</td>
	<td>data2 = undefined &#150; ignore</td>
</tr>

<tr>
	<td><b>4</b></td>
	<td>Controller Event:</td>
	<td>data1 = controller no</td>
	<td>data2 = value (msb)</td>
</tr>
</table>
</div>

<p>
<b>Notes:</b><br>
<dl>
<dt>PITCHBEND:</dt> <dd>the value can be 7-bit (lo-res) or 14-bit (hi-res)
	<ul>
	<li>lo-res range: 0 &shy; 127 &nbsp;&#150;&nbsp; centre (no-bend) = 64
	<li>hi-res range: 0 - 16383 &nbsp;&#150;&nbsp; centre(no-bend) = 8192
	</ul>
<dt>CONTROLLER:</dt> <dd>only the lo-res (8-bit) value is returned
	<ul>
	<li>The second data byte for 14-bit hi-res controllers is dropped.
	<li>For switches, ON = <b>127</b>, OFF = <b>0</b>
	<li>Note that controller information may be instrument-specific
	    &#150; refer to the MIDI specification for information on
	    controller numbers and messages.
	</ul>
</dl>
</p>

</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>

<h2 id="MIDIOUT"><b>midiout</b> &#150; Rule</h2>

<blockquote>
<p>
Output a MIDI message.
</p>

<p>
Example:
</p>
<blockquote>
<code><b>midiout chan, note, vel, dur [, num_notes]</b></code>
</blockquote>

<p>
The input arguments are:
</p>
	<blockquote>
	'chan' is the Channel number (0 &shy; 15)<br>
	'note' is the MIDI note number (0 &shy; 127)<br>
	'vel' is velocity (0 - 127) (i.e., loudness)<br>
	'dur' is the duration (in seconds)<br>

	<p>
	[optional:]<br>
	'num_notes' is the number of notes to be output simultaneously
	&#150;  the default is 1.
	</blockquote>

<p>
If a rest is to be specified, then the MIDI note number (the value of
the second input argument) should be made negative.
</p>

<p>
If fewer than 'num_notes' notes caused by this <b>midiout</b> rule are
playing when the rule is executed, then a new note specified by
'chan', 'note', 'vel' and 'dur' is started, and the return status is
the number of notes now playing.  Otherwise there are at least
'num_notes' already playing and so the rule does not start a new note;
the return status is minus the number of notes currently playing.
</p>

<p>
Thus<br>
<blockquote>
<code><b>midiout 0, 65, 100, 1.5</b></code>
</blockquote>
</p>

<p>
will output one note event each time it is executed and the previous
note has terminated.
</p>

<blockquote>
<code><b>midiout 0, note, 100, dur, 3</b></code>
</blockquote>

<p>
will keep three notes playing.  Whenever a note finishes a new note
will be added, using the current values of 'note' and 'dur'.
</p>

<p>
Any of the first four input parameters may be tables, in which case
the first 'num_notes' table elements are used as the parameters to
output 'num_notes' events.
</p>

<h3>
Rule Return Status:
</h3>

<p>
If the rule has succeeded in outputting any notes, the return status
is the number of notes currently playing.
</p>

<p>
Otherwise the return status is minus the number of notes currently playing.
</p>

<p>
<b>NB</b> Executing the rule with 'num_notes' equal to zero returns
minus the number of notes currently playing;  a new note will never be
launched in this event.
</p>

</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>

<h2 id="MIDISET"><b>midiset</b> &#150; Rule</h2>

<blockquote>
<p>
This rule may be used to set instruments to specific MIDI channels
before performance.  It may also be used to re-set instruments during
performance if required.  There are two input parameters:  Channel
number (0 &shy; 15) and Instrument number (0 - 127).
</p>

<p>
Example:
</p>

<blockquote>
<code><b>midiset 0, 54<br>
midiset 1, 63</b></code>
</blockquote>

<h3>
Rule Return Status:
</h3>

<p>
Always <b>1</b>
</p>

</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>


<h2 id="MIN"><b>min</b> &#150; Rule</h2>

<blockquote>
<p>
Output is the minimum value of up to nine input cells.
</p>

<p>
Example:
</p>

<blockquote>
<code><b>a min b, c, d, e</b></code>
</blockquote>

<p>If a cumulative result &#150; over many iterations of a performance
loop &#150; is required, include the output cell in the input cell list,
as in the following:
</p>

<blockquote>
<code><b>a min a, b, c, d, e</b></code>
</blockquote>

<h3>
Rule Return Status:
</h3>
<p>
<b>1</b> if the rule has been correctly applied<br>
<b>0</b> if the rule has failed (because the output cell is locked).
</p>

</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>

<h2 id="MOUSE"><b>mouse</b> &#150; Rule</h2>

<blockquote>
<p>
Prototype:
</p>

<p>
<blockquote>
<code><b>x, y mouse [scale1, scale2, scale3, scale4]</b></code>
</blockquote>
	<p>
	<blockquote>
	Output Cell 'x': Mouse 'x' coordinate<br>
	Output Cell 'y': Mouse 'y' coordinate
	</blockquote>
	</p>
</p>

<p>
Gives two outputs, which are normalised screen coordinates of the
mouse position (though on Atari the mouse cursor will be invisible!).
If there are no input parameters, then the outputs are scaled
between <b>0</b> and <b>1</b>.  If there are input arguments, then
these will scale the 'x' and 'y' values accordingly:
</p>
	<p>
	<blockquote>
	'scale1': Scale Value when mouse position is furthest left<br>
	'scale2': Scale Value when mouse position is furthest right<br>
	'scale3': Scale Value when mouse position is lowest<br>
	'scale4': Scale Value when mouse position is highest
	</blockquote>
	</p>

<p>
Examples:
</p>

<pre><code><blockquote><b>
x, y      mouse
          probe     x, y

x, y      mouse     36, 96, -5.0, 5.0
          probe     x, y
</b></blockquote></code></pre>

<p>
Cell 'x' will represent the horizontal location of the mouse, and
'y' will represent its vertical location.  In the first example, a value
lying between 0 and 1 will result in 'x' and 'y'.  In the second
example 'x' will lie between 36.0 and 96.0, 'y' between -5.0 and +5.0.
</p>

<h3>
Rule Return Status:
</h3>

<p>
Always <b>1</b>
</p>

</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>


<h2 id="MULT"><b>mult</b> &#150; Rule</h2>

<blockquote>
<p>
Place in an output cell the result of multiplying the values of any
number  of  input cells.
</p>

<p>
Example:
</p>
<blockquote>
<code><b>a mult b, c, d</b></code>
</blockquote>

<p>
The example given is equivalent to the equation
</p>
<blockquote>
<code><b>a = b * c * d</b></code>
</blockquote>

<p>
If  output cell 'a' is unlocked, then its value will become the result
of multiplying b, c and d. If it is locked, then each of the unlocked
input cells is re-evaluated.  If all cells are locked, then the rule
return status records 1 or 0, depending on whether the two sides of
the equation balance or not.
</p>

<h3>
Rule Return Status:
</h3>

<p>
<b>1</b> if both sides of the opname are equal<br>
<b>0</b> if the <b>mult</b> operation has failed (because the output
cell is locked)
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>


<h2 id="MULTTABLE"><b>mult_table</b> &#150; Rule</h2>

<blockquote>
<p>
Multiply each value in a table by its corresponding index value in
a second table, and places the result in the output table. Example:
</p>

<blockquote>
<code><b>A mult_table B, C</b></code>
</blockquote>

<p>
If the table sizes are unequal, then operations to the size of the
smallest table only will occur.
</p><p>
Note &#150; this rule does not apply to string tables.
</p>


<h3>
Rule Return Status:
</h3>

<p>
Always <b>1</b>
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>


<h2 id="NATLOG"><b>natlog</b> &#150; Mathematical function</h2>


<blockquote>
<p>
Gives the logarithm, base e, of any number, where
'e' = 2.718281828....
<p>
Example:
</p>
<blockquote>
<code><b>
a = natlog(b)
</b></code>
</blockquote>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>

<h2 id="NUM2STRING"><b>num2string</b> &#150; Type-conversion Function</h2>
<blockquote>
<p>
Converts a floating-point number to a string.
</p><p>
Examples:
</p><p>
<blockquote>
<code><b>
num2string(6.53)
<br>
int2string(float_variable) 
</b></code>
</blockquote>
</p><p>
The function enables an floating-point value to be displayed by <b>message</b> &#47; <b>messag1</b> or stored by <b>storstr</b>, using their second format in which one or more strings are enclosed within double-chevrons  &lt;&lt; &nbsp; &gt;&gt;. (See message or storstr for an example.)
 
</p><p>
The converted string cannot be assigned to a variable or an element of a string table. Thus the following will give syntax errors:
  <blockquote>
  <code><b>
  a = num2string(6.53)
  <br>
  'STRTABLE[0] = num2string(6.53)
  </b></code>
  </blockquote>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a> to TV Index
</p>

<h2 id="OFFSETTABLE"><b>offset_table</b> &#150; Rule</h2>

<blockquote>
<p>
Offset the contents of a table by a value, and write to an output table.
</p>

<p>
Examples:
</p>

<blockquote>
<code><b>
A offset_table B, -1.0<br>
A offset_table B, c
</b></code>
</blockquote>

<p>
In these cases, each value in table B is offset, by the constant
-1.0 and the current value of cell 'c' respectively, to produce
the corresponding value in table 'A'.
</p>

<p>
If the table sizes are unequal, then operations to the size of the
smallest table only will occur.
</p>

<h3>
Rule Return Status:</h3>

<p>
Always <b>1</b>
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>


<h2 id="PERM"><b>perm</b> &#150; Rule</h2>

<blockquote>
<p>
Randomly, or by step or skip, permute the contents of a
one-dimensional input table.
</p>

<p>
Examples:
</p>

<blockquote>
<code><b>perm A</b></code>
</blockquote>

<p>
will permute the contents of table A.
</p>

<blockquote>
<code><b>perm A, 1</b></code>
</blockquote>

<p>
will permute table A by one step (ie two values in the table will be
swapped). Successive calls with the same step value of 1 will cycle
through all possible permutations of the table and a particular order
will not repeat until all permutations have been iterated. The number
of permutations is dependent upon the table size. The following gives
the number of permutations for table sizes up to 8.
</p>

<blockquote>
<table>
<caption><b>Permutations per Table Size</b></caption>

<tr>
<th align=center>Table Size</th> <th align=center>Number of permutations</th>
</tr>

<tr>
<td align=center>2</td> <td align=center>2</td>
</tr>

<tr>
<td align=center>3</td> <td align=center>6</td>
</tr>

<tr>
<td align=center>4</td> <td align=center>24</td>
</tr>

<tr>
<td align=center>5</td> <td align=center>120</td>
</tr>

<tr>
<td align=center>6</td> <td align=center>720</td>
</tr>

<tr>
<td align=center>7</td> <td align=center>5040</td>
</tr>

<tr>
<td align=center>8</td> <td align=center >40320</td>
</tr>
</table>
</blockquote>

<p>
As the number of permutations increases according to the factorial of
the table size (<b>n!</b>), the use of step permutation with larger
table sizes is not recommended. This stricture does not apply to random
permutations.
</p>

<blockquote>
<code><b>perm A, skip</b></code>
</blockquote>

<p>
will permute table A by 'skip' steps.  If skip is 2, every other step
permutation will result, and the permutation cycle will be completed
in half the number of steps. If 'skip' is otherwise a factor of the
table size, the cycle will be correspondingly reduced. If 'skip' is a
prime number not otherwise a factor of the table-size factorial, then
an alternative path through the complete cycle of permutations will
result. If 'skip' is negative, then the permutation cycle will be
traversed 'backwards' - ie, with a table size of 4, <b>perm</b> A, -1
is equivalent to <b>perm</b> A, 23.
</p>

<p>
For reference, the following lists in four columns the size-4 table
indices of a complete permutation cycle with a stepsize of 1:
</p>
	<p>
	<blockquote>
	1 2 3 4<br>
	1 2 4 3<br>
	1 3 2 4<br>
	1 3 4 2<br>
	1 4 2 3<br>
	1 4 3 2<br>
	2 1 3 4<br>
	2 1 4 3<br>
	2 3 1 4<br>
	2 3 4 1<br>
	2 4 1 3<br>
	2 4 3 1<br>
	3 1 2 4<br>
	3 1 4 2<br>
	3 2 1 4<br>
	3 2 4 1<br>
	3 4 1 2<br>
	3 4 2 1<br>
	4 1 2 3<br>
	4 1 3 2<br>
	4 2 1 3<br>
	4 2 3 1<br>
	4 3 1 2<br>
	4 3 2 1<br>
	</blockquote>
	</p>

<h3>
Rule Return Status:
</h3>

<p>
Always <b>1</b>
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>


<h2 id="PITCHBEND"><b>pitchbend</b> &#150; Rule</h2>

<blockquote>
<p>
Send a MIDI pitchbend message.  There are two input parameters, containing
the Channel (0-15) and pitchbend value respectively.
</p>

<p>
Bear in mind that the pitchbend range is normally set on the synthesizer
itself.  If this is set to one semitone,  then the following will set
notes on channel 4 to be a quarter-tone sharp:
</p>

<blockquote>
<code><b>pitchbend 3, 96</b></code>
</blockquote>

<h3>
Rule Return Status
</h3>

<p>
Always <b>1</b>
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>


<h2 id="POP"><b>pop</b> &#150; Rule</h2>

<blockquote>
<p>
Fractal algorithm which employs an output cell and an input value.
Example rule-line:
</p>

<blockquote>
<code><b>a pop r</b></code>
</blockquote>

<p>
This algorithm is commonly referred to as the 'population' equation, from
which the opname gets its name.  It can be expressed:
</p>

<blockquote>
<code><b>a</sub><sup>next</sup> = r * a * (1.0 - a)</b></code>
</blockquote>

<p>
In this implementation of the algorithm, if the input cell 'a' happens
to be larger than 1.0, then the reciprocal of this value is first
substituted before the re-evaluation of the cell 'a'.  As the value
'r' (normally a constant) is allowed to approach 4.0, the output
results in more 'chaotic' behaviour. This value is not limited, so
care should be taken by the user.
</p>

<h3>
Rule Return Status:
</h3>

<p>
<b>1</b> if the algorithm has been successfully applied<br>
<b>0</b> if the output cell has been locked
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>


<h2 id="POWER"><b>power</b> &#150; Mathematical Function </h2>

<blockquote>
<p>
Power function. Example:
</p>

<blockquote>
<code><b>a = power(b, c)</b></code>
</blockquote>

<p>
Output 'a' is 'b' to the power of 'c'. To square a value, use:
</p>

<blockquote>
<code><b>a = power(a, 2)</b></code>
</blockquote>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>


<h2 id="PRINT"><b>print</b> &#150; Rule</h2>

<blockquote>
<p>
Print to the console the input argument. There are optional formatting fields.
</p>

	<blockquote>
	<code><b>print x [, format1, format2]</b></code><br>
	<p>
	'x' is the cell whose contents are to be printed.
	</p>
	<p>
	'format1' is the total number of screen characters to be taken
	in printing the value.
	</p>
	<p>
	format2' is the number of decimal places to be printed.
	The value is rounded to the last digit.
	</p>
	<p>
	If 'format1' and 'format2' are omitted, the rule
	defaults to 6 for format1 and 2 for format2.
	</p>
	<p>
	If 'format2' is given the value 0, then the number will be
	displayed as an integer.
	</p>
	</blockquote>

<p>
In the following example, the cell 'x' has been initialised to 2.157042.
</p>

<blockquote>
<table border=3 cellpadding=4>
<caption><b>PRINT format options</b></caption>

<tr>
<th align-center>Examples:</th>
<th align=center>Result:</th>
</tr>

<code>
<tr>
<td>print x</td>
<td>2.16</td>
</tr>

<tr>
<td>print x, 4, 1</td>
<td>2.2</td>
</tr>

<tr>
<td>print x, 6, 2</td>
<td>2.16</td>
</tr>

<tr>
<td>print x, 8, 3</td>
<td>2.157</td>
</tr>

<tr>
<td>print x, 10,4</td>
<td>2.1570</td>
</tr>

<tr>
<td>print x, 10,5</td>
<td>2.15704</td>
</tr>

<tr>
<td>print x, 10,6</td>
<td>2.157042</td>
</tr>
</code>
</table>
</blockquote>

<p>
Note that no carriage return or newline characters are output, so if the
user wishes to incorporate line formatting, this must be done with
message, e.g.
</p>

<blockquote>
<code><b>message "\n"</b></code>
</blockquote>

<p>
after print calls.
</p>
<p>
The <b>print</b> rule does not take a string parameter. Use <b>message &#47; messag1</b> for this instead.
</p>


<h3>
Rule Return Status:
</h3>

<p>
Always <b>1</b>
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>


<h2 id="PROBE"><b>probe</b> &#150; Rule<br>
<a name="PROBI"><b>probi</b></a> &#150; Rule
</h2>

<blockquote>
<p>
Display the input arguments on the console.  These rules are designed
to show lists of cell values or arguments.  Up to 10 can be displayed
on an 80-character window, each pair separated by a tab.  No newline
is generated, so if the user wishes to see repeated calls to <b>probe</b>
or <b>probi</b>, a message rule of the type
</p>

<blockquote>
<code><b>message "\n"</b></code>
</blockquote>

<p>
must be used after the probe line.
</p>

	<blockquote>
	<b>probe</b> displays values to 2 decimal places.<br>
	<b>probi</b> displays values as integers.
	</blockquote>

<p>
Example:
</p>

<blockquote>
<code><b>probe a, b, c</b></code>
</blockquote>

<p>
Rule Return Status:
</p>

<p>
Always <b>1</b>
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>


<h2 id="RAND"><b>rand</b> &#150; Mathematical Function</h2>

<blockquote>
<p>
Prototype:
</p>

<blockquote>
<code><b>a = rand()</b></code>
</blockquote>

<p>
The output is a random floating point number lying between 0 and 1
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>



<h2 id="RANDOM"><b>random</b> &#150; Mathematical Function</h2>

<blockquote>
<p>
Prototype:
</p>

<blockquote>
<code><b>a = random(p, q)</b></code>
</blockquote>

<p>
The output is a random floating point number lying between the input
arguments ('p' and 'q' in the prototype above).
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>


<h2 id="RETURN"><b>return</b> &#150; Control-flow</h2>

<blockquote>
<p>
Without a label, this means return to the last procedure.  With a label,
it means 'search for the most recent call with that label, and return
to it. Example:
</p>

<blockquote>
<code><b>return saturn</b></code>
</blockquote>

<p>
means return to the latest call with the label 'saturn'.  Note, therefore,
that more than one call can refer to the same label &shy; the latest
one is always used used, so there is no ambiguity.
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>


<h2 id="ROUND"><b>round</b> &#150; Mathematical Function</h2>

<blockquote>
<p>
Return the nearest rounded integer value of a number. Examples:
</p>

<blockquote>
<code><b>x = round(77.35)</b></code>
</blockquote>

<p>
will assign the value 77.00 to x, and
</p>

<blockquote>
<code><b>a = 55.2<br>
b = round(a)</b></code>
</blockquote>

<p>
will assign the value 55.0 to b.
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>


<h2 id="SCALETABLE"><b>scale_table</b> &#150; Rule</h2>

<blockquote>
<p>
Scale each cell in a table by a constant value to produce an output
table. Examples:
</p>

<blockquote>
<code><b>A scale_table B, 3.3<br>
A scale_table B, c</b></code>
</blockquote>

<p>
In these cases, each value in table 'B' is multiplied by 3.3 and 'c'
respectively to produce the output values in table 'A'.
</p>
<p>
Note &#150; this rule does not apply to string tables.
</p>


<h3>
Rule Return Status:
</h3>
<p>
Always <b>1</b>
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>


<h2 id="SCHEDULE"><b>schedule</b> &#150; Rule</h2>

<blockquote>
<p>
Schedule a MIDI event for later performance. Example:
</p>

<blockquote>
<code><b>schedule channel, pitch, velocity, duration, delay</b></code>
</blockquote>

<p>
The scheduled event will occur 'delay' seconds later.
</p>

<h3>
Rule Return Status:
</h3>

<p>
Number of events scheduled for future performance.
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>


<h2 id="SEG"><b>seg</b> &#150; Rule</h2>

<blockquote>
<p>
Create a linear time-varying output between values supplied by the user.
</p>

<p>
The prototype of the rule is:
</p>

	<blockquote>
	<code><b>out seg dur, value1, value2</b></code>
	<p>
	'out' is the current value of the output<br>
	</p>
	<p>
	'dur' is the duration over which <b>seg</b> creates the
	linear time-varying value.
	</p>
	<p>
	'value1' and 'value2' are the limits of the linear segment.
	</p>
	</blockquote>
<p>
NB Contrast this rule with <b>lin</b>, which moves back and forth
between minimum and maximum values.
</p>
</blockquote>


<h3>
Rule Return Status:
</h3>

<p>
<b>1</b> when <b>seg</b> is first called, and thereafter when the end of
each linear segment has been reached.<br>
<b>0</b> on every other occasion.
</p>
</blockquote>


<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>

<h2 id="SHIFT"><b>shift</b></a> &#150; Rule</h2>

<blockquote>
<p>
Shift contents of a one-dimensional table one place to the left [or right].
</p>

<p>
Prototype:
</p>

<blockquote>
<code><b>shift A [, direction]</b></code>
</blockquote>

<p>
If 'direction' is missing or is set to zero, then the contents of the
input table are moved one place to the right, and the value of the last
cell moves to the first.  If 'direction' is non-zero, then the contents
of the table are moved one place to the left, and the contents of the
first cell gets moved to the last.
</p>

<h3>
Rule Return Status:
</h3>

<p>
Always <b>1</b>
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>

<h2 id="SHOWARGS"><b>showargs</b> &#150; Rule</h2>

<blockquote>
<p>
Show (within a script) arguments invoked on the commandline.
</p>

<p>
Prototype:
</p>

<blockquote>
<code><b>showargs args(1)</b></code>
</blockquote>

<p>
The prototype will show the first argument string (after the script name) on the commandline.<br>
If the script is named 'argstr.tv', and invoked with<blockquote><code>
tv argstr data.txt &lt;RETURN></code><p></blockquote>
then the prototype script line above will display<br><p><code><blockquote>
data.txt
</blockquote></code></p>
<p>Script example:
<br><code><pre>
// 'strarg.tv' - Show commandline string arguments
start()
{
	message "Args(1) is "
	showargs args(1)
	message "\nArgs(2) is "
	showargs args(2)
	message "\nArgs(3) is "
	showargs args(3)
	message "\nArgs(4) is "
	showargs args(4)
}
</code></pre>
If this is invoked on the commandline with
<code><pre>
tv strarg data.txt Tuesday 6.37 Thursday &lt;RETURN>
</pre></code>
then the output will be:
<code><pre>
Args(1) is data.txt
Args(2) is Tuesday
Args(3) is 6.37
Args(4) is Thursday
</code></pre>
Note that the number in string argument(3) is shown exactly as it appeared, as a string. <br>
Numbers can, however, also be displayed with 'print', as
<code><pre>
print arg(3), 4, 2
</code></pre>
in this case.

<h3>
Rule Return Status:
</h3>

<p>
<b>None</b>
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>


<h2 id="SINE"><b>sine</b> &#150; Mathematical Function</h2>

<blockquote>
<p>
Give the sine of a value in radians;  the output will thus always be a
value between -1.0 and +1.0.
</p>

<p>
Examples:
</p>

<blockquote>
<code><b>a = sine(2.17)<br>
a = sine(b)</b></code>
</blockquote>

<p>
Places the sine of the input cell in cell 'a'.
</p>

<p>
The following is a complete rule-file which will demonstrate <b>sine</b>.
</p>

<pre><code><blockquote><b>
// Demonstrate sine function.
start()
{
    pi2 = 6.28318530717958647692
    while(1) {
        a       sum     a, 0.001
        b = sine(a)
        probe   a, b
        a %= pi2
    }
}
</b></blockquote></code></pre>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>


<h2 id="SORT"><b>sort</b> &#150; Rule</h2>

<blockquote>
<p>
Sort a table into ascending or descending order.
</p>

<p>
Prototype:
</p>

<blockquote>
<code><b>sort AAA [, sort_flag]</b></code>
</blockquote>

<p>
If <b>sort_flag</b> is absent or is equal to zero, then the input
table is sorted into ascending order.  If <b>sort_flag</b> is non-zero,
then the table is sorted into descending order.<br>
NOTE: Currently only one-dimensional tables are supported with this rule.
</p>

<h3>
Rule Return Status:
</h3>

<p>
Always <b>1</b>
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>


<h2 id="SQRT"><b>sqrt</b> &#150; Mathematical Function</h2>

<blockquote>
<p>
Give the square root of a value. Example:
</p>

<blockquote>
<code><b>a = sqrt(b)</b></code>
</blockquote>

<p>
Places the square root of cell 'b' into cell 'a'.
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>

<!--
<h2 id="SPAWN"><b>spawn</b> &#150; External Program call</h2>

<blockquote>
<p>
Spawns a new external program process, which runs in parallel with the TV script. <br>
The program may be any within the current path (e.g. 'dirsf' or any CDP processing programs).
For system calls, use 'system'. Redirection in 'spawn' is NOT supported.<br>The entire command must be
enclosed within inverted commas.<br>
Examples:
</p>
<blockquote>
<code><b>
start()<br>
{<br>&nbsp&nbsp&nbsp&nbsp&nbsp
	message "Test for SPAWN and SYSTEM!\n"<br>&nbsp&nbsp&nbsp&nbsp&nbsp
	spawn "dirsf -d D:/"<br>&nbsp&nbsp&nbsp&nbsp&nbsp
	message "\nSpawn call to 'dirsf' completed.\n"<br>&nbsp&nbsp&nbsp&nbsp&nbsp
	system "dir"<br>&nbsp&nbsp&nbsp&nbsp&nbsp
	message "\nSystem call to 'dir' completed.\n"<br>
}<br>
</blockquote></code></b>

<p><b>NB</b> 1. Unlike 'system' (q.v.), when 'spawn' is invoked it will run in parallel with the current TV<br>
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp script. Time-sensitive triggering is thus preserved.<br>
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp2. On the script line invoking 'spawn', any path separators must be either
a single '/'<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp (as in the script shown above), or a double '\\'.<br>
<br><b>'spawn'</b> can be particularly useful to call 'playsfx' to play a soundfile in the midst of a MIDI performance.
An example of this usage is given in the Demonstration scripts.<br>

</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>

-->

<!-- **************************************************** -->
<h2 id="STOREDIGITS"><b>store_digits</b> &#150; Rule<br>
<a name="STORE"><b>store</b></a> &#150; Rule<br>
<a name="STORF"><b>storf</b></a> &#150; Rule<br>
<a name="STORI"><b>stori</b></a> &#150; Rule<br>
<a name="STOREFILE"><b>storefile</b></a> &#150; Rule<br>
<a name="STORSTR"><b>storstr</b></a> &#150; Rule
</h2>

<blockquote>
<p>
It is possible to store in a file values generated during the course
of a performance.  This enables, for example, re-runs of performances
generated in real-time from statistical data.
</p><p>
The name of the <b>storefile</b> must be given in the form:
</p>
<blockquote>
<code><b>storefile "params"</b></code>
</blockquote>
<p>
If the file named already exists, then it will be overwritten.
</p>
<p>
The opname <b>store</b> has identical parameters to that of <b>probe</b>, and permits
cell-values to be stored as floating point values to two decimal
places in a single line of text in <b>storefile</b>.  <b>stori</b> will store these values
as integers, and <b>storstr</b> allows an ASCII string to be placed in
the storefile.  

<p>
The opnames <b>store</b>, <b>stori</b> and <b>storstr</b> are invoked thus:
</p>

<blockquote>
<code><b>store var1, var2, var3 .....[etc]<br>
stori var1, var2, var3 .....[etc]<br>
storstr "One string in quotation marks"
</b></code>
</blockquote>

<p>
The following may be included within the quotation marks of
<b>storstr</b>, for formatting purposes:
</p>

<blockquote>
<code><b>\n</b></code> (Newline)<br>
<code><b>\t</b></code> (Tab)
</blockquote>

<h3>
<b>Multiple Output Files<br></b>
</h3>
<p>
From Version 1.33, it is possible to create more than one output file simultaneously. All files subsequent to the first are declared as follows:
</p>
<blockquote>
<code><b>storefile <i>n</i> filename</b></code><br>
&nbsp&nbsp&nbsp&nbspwhere <i>n</i> is an integer identifier (e.g. 1)
</blockquote>
<p>
In the script, <b>store</b> and <b>stori</b> will <b>not</b> work with these integer-identified
storefiles. Instead, the storage opname <b>storf</b> ('storefloat') should be used.

With this opname it is possible to select in advance how many decimal places will be included in the storage, with the
declaration
</p>
<blockquote>
<code><b>store_digits 4</b></code>
</blockquote>

<p>
Note that this is a global declaration - i.e., all variables stored with <b>storf</b> will
have four decimal places. <br>
If you wish to store integers with <b>storf</b>, simply declare '<b>store_digits 0</b>'.  
</p><p>
<b>Storstr</b> does work with these files, however: simply add the integer identifier after the opcode '<b>storstr</b>':
</p>
<blockquote>
<code><b>storestr 1 "sometext"
</b> </code>
</blockquote>

<p>
The following is a complete script which demonstrates writing multiple output files:<br>
<blockquote>
<code>
// File 'stortest.tv'<br>
start()<br>
{<br>
	&nbsp&nbsp&nbsp&nbspstorefile "pitchesA.txt"<br>
	&nbsp&nbsp&nbsp&nbspstorefile 1 "pitchesB.txt"<br>
	&nbsp&nbsp&nbsp&nbspstorefile 2 "pitchesC.txt"<br>
	&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspstore_digits 0<br><br>
	&nbsp&nbsp&nbsp&nbspstorstr "// PitchesA.txt\n"<br>
	&nbsp&nbsp&nbsp&nbspfor(i=0; i<10; i+=1) {<br>
	&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsppitch = int(random(60, 73))<br>
	&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspstori pitch<br>
	&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspstorstr "\t"<br>
	&nbsp&nbsp&nbsp&nbsp}<br>
	&nbsp&nbsp&nbsp&nbspstorstr "\n"<br><br>
	&nbsp&nbsp&nbsp&nbspstorstr 1 "// PitchesB.txt\n"<br>
	&nbsp&nbsp&nbsp&nbspfor(i=0; i<12; i+=1) {<br>
		&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsppitch = int(random(48, 59))<br>
		&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspstorf 1, pitch<br>
		&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspstorstr 1 "\t"<br>
	&nbsp&nbsp&nbsp&nbsp}<br>
	&nbsp&nbsp&nbsp&nbspstorstr 1 "\n"<br><br>
	&nbsp&nbsp&nbsp&nbspstorstr 2 "// PitchesC.txt\n"<br>
	&nbsp&nbsp&nbsp&nbspfor(i=0; i<24; i+=1) {<br>
		&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsppitch = int(random(72, 97))<br>
		&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspstorf 2, pitch<br>
		&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspstorstr 2 "\t"<br>
	&nbsp&nbsp&nbsp&nbsp}<br>
	&nbsp&nbsp&nbsp&nbspstorstr 2 "\n"<br>
}<br></code>
</blockquote>
</p>

<h3>Multiple expressions in storstr</h3>
<p>
From Version 1.5, it is possible to contain multiple expressions, including variables, in the same store-string. For CDP users, this makes it possible to write command-lines and mixfiles, for instance.
</p><p>
The overall format is the same as Format 2 used in message &#47; messag1, namely string items separated with commas and placed within a container of double-chevrons: &lt;&lt; ... , ... &gt;&gt; .
</p><p>
Text including \n and \t is contained in double quotes in the usual way: "\n" and "\t", and "\nSome text" and "some text\n" continue to be valid (i.e., newlines included in the same quotes as the text string).
</p><p>
Storstr example (Format 2):
</p>
<blockquote>
<b><code>
intvar = 1<br>
storestr << "\nSoundfile ", int2string{intvar), "\t", 'SOUNDFILES[0], "\n\n" >><br>
</b></code></blockquote>

<p>
For a single string-table cell, the format is not needed, as it is already a string: <b>storstr 'SOUNDFILES[0]</b> is acceptable.
</p>


<h3>
Rule Return Status:
</h3>

<p>
<b>store, storf</b> and <b>stori</b> &#150; Always <b>1</b><br>
<b>storefile, storstr</b> and <b>store_digits</b> &#150; None
</p>
</blockquote>


<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>


<h2 id="SUBST"><b>subst</b></a> &#150; Rule</h2>

<blockquote>
<p>
Place in an output table values drawn statistically from either of two
input tables.
</p>

<p>
Prototype:
</p>

<blockquote>
<code><b>C subst A, B, fac</b></code>
</blockquote>

<p>
'fac' is a statistical substitution index factor, whose value lies
between 0 and 1.
</p>

	<p>
	<blockquote>
	When 'fac' is 0, table 'C' copies table 'A'.<br>
	When 'fac' is 1, table 'C' copies table 'B'.<br>
	When 'fac' is some value between 0 and 1, each value of
	table 'C' is drawn from table 'A' or 'B' depending on the
	value of the factor.  Since the choice is made statistically,
	repeated calls to subst even with the same substitution index
	is likely to produce a different output table.
	</blockquote>
	</p>

<h3>
Rule Return Status:
</h3>

<p>
Always <b>1</b>
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>


<!-- end of tvm5ae.htm -->
<!-- start of tvm6ae.htm -->


<h2 id="SUM"><b>sum</b> &#150; Rule</h2>

<blockquote>
<p>
Sum in the output cell the input arguments.
</p>

<p>
Example:
</p>

<blockquote>
<code><b>a sum  b, c, d, e, f</b></code>
</blockquote>

<p>
If the output cell is unlocked, then cell 'a' will contain the sum of
cells 'b' to 'f'.  If 'a' is locked, then those cells 'b' to 'f' which
are unlocked will be incremented (or decremented) equally to satisfy
the equation.
</p>

<blockquote>
<code><b>a = b + c + d + e + f</b></code>
</blockquote>

<p>
If all cells are locked, then the rule return status will be either
<b>1</b> or <b>0</b> depending whether the equation is satisfied.
</p>

<p>
<b>sum</b> may be used to increment or decrement a cell, by naming it
as both  input and output, as:
</p>

<blockquote>
<code><b>a sum a, -0.01</b></code>
</blockquote>

<h3>
Rule Return Status:
</h3>

<p>
<b>1</b> if both sides of the opname sum are equal<br>
<b>0</b> if the output cell is locked and as a result the equation
cannot  be satisfied.
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>


<h2 id="SUMTABLE"><b>sum_table</b> &#150; Rule</h2>

<blockquote>
<p>
This rule sums successive values in two tables to produce corresponding
values in the output table. Example:
</p>

<blockquote>
<code><b>A sum_table B, C</b></code>
</blockquote>

<p>
In this case successive values in table 'B' are added to successive
values in table 'C' to produce the successive values in table 'A '.  If
the tables are of unequal size, then only the minimum-size table values
will result.
</p><p>
<p>
Note &#150; this rule does not apply to string tables.
</p>


<h3>
Rule Return Status:
</h3>

<p>
Always <b>1</b>
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>


<h2 id="SWAP"><b>swap</b> &#150; Rule</h2>

<blockquote>
<p>
Swap the values of two cells. Cells within tables may be swapped. Examples:
</p>

<blockquote>
<code><b>swap a, b</b></code> &#47;&#47; Values in cells 'a' &amp; 'b'
are swapped<br>
<code><b>swap a, D[5]</b></code> &#47;&#47; Values in 'a' and D[5]
are swapped<br>
<code><b>swap D[0], D[7]</b></code> &#47;&#47; Values in D[0] and D[7]
are swapped
</blockquote>

<p>
If a cell is locked, then no swap will occur.
</p>

<h3>
Rule Return Status:
</h3>

<p>
<b>1</b> if the swap has occurred<br>
<b>0</b> if no swap has occurred
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>

<h2 id="SWITCHON2"><b>switchon/case </b> &#150; Control-flow</h2>

<blockquote>
<p>
Conditionally branch to alternate code segments.
</p>

<blockquote>
Example:
</blockquote>

<blockquote>
<code>switchon a { <br>
	&nbsp&nbsp&nbsp&nbspcase 0: {<br>
	&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspcall rotate()<br>
	&nbsp&nbsp&nbsp&nbsp}<br>
	&nbsp&nbsp&nbsp&nbspcase 1: {<br>
	&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspcall tumble()<br>
	&nbsp&nbsp&nbsp&nbsp}<br>
	&nbsp&nbsp&nbsp&nbspcase 2: {<br>
	&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspcall undulate()<br>
	&nbsp&nbsp&nbsp&nbsp}<br>
	&nbsp&nbsp&nbsp&nbspcase 3: {<br>
	&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspcall veer()<br>
	&nbsp&nbsp&nbsp&nbsp}<br>
	&nbsp&nbsp&nbsp&nbspdefault: {<br>
	&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspdum = 0	// do nothing!<br>
	&nbsp&nbsp&nbsp&nbsp}<br>
	}
</code>
</blockquote>

</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>

<h2 id="SYSTEM"><b>system</b> &#150; System call</h2>

<blockquote>
<p>
Creates a system call to an external program. <br>
The program may be one normally accessible to the commandline interface (e.g. 'dir'),
or it may be any program within the current path. Redirection is supported.
</p><p>
From Version 1.5, there are two formats available for the command.<br>
Format 1: the entire command is enclosed within inverted commas.<br>
Examples:

</p>

<blockquote>
<code><b>system "dir >dirlist.txt"<br>&nbsp&nbsp&nbsp&nbsp&nbsp</b></code> &#47;&#47;
 Writes the current directory listing into a file 'dirlist.txt'.<br>
<code><b>system "dirsf C:\Sounds"<br>&nbsp&nbsp&nbsp&nbsp&nbsp</b>
</code> &#47;&#47; Lists the soundfiles in the named directory.<br>
<code><b>system "sndinfo len C:\Sounds\rock.wav"<br>&nbsp&nbsp&nbsp&nbsp&nbsp</b>
</code> &#47;&#47; Writes the length of the named soundfile to the console.<br>
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
</code> &#47;&#47; In the latter examples the path to the CDP executables <br>
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp</code> &#47;&#47; must be made known to the operating system.<br>
</blockquote>

<p>
Format 2 (from Version 1.5): multiple strings are placed within double-chevrons  &lt;&lt; &nbsp; &gt;&gt;, as also used in <b>message &#47; message1</b> and <b>storstr</b>.<br>
Example:
<blockquote>
<code><b>
    mode = 2  <br>
    paramup = 12  <br>
    system << "modify speed ", int2string(mode), " ", 'SFILES[0], " ", 'SFILES[1], " ", int2string(paramup) >> <br>
</b></code>
</blockquote>
<p>
This assembles and runs the CDP commandline: "modify speed 2 infile.wav outfile.wav 12" (where 'SFILES[0] and 'SFILES[1] were previously read from a textfile). The advantages of being able to run CDP commands from within <i>Tabula Vigilans</i> cannot be over-stated. 
</p>
<p>Note that when <b>system</b> is invoked, the entire control is passed to the called process.
 Any timing features of the script are interrupted until the called process returns control to TV.
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>

<h2 id="TABLE"><b>table</b> &#150; Initialisation Rule</h2>

<blockquote>
<p>
Create a (numerical) table of given dimensions and sizes. Examples:
</p>

<blockquote>
<code><b>table SOME[8]</b></code> &#47;&#47;
 1 dimension, 8 cells<br>
<code><b>table MANY[20][2]</b></code> &#47;&#47; 2 dimensions, 20 x 2<br>
<code><b>table MORE[3][3][3]</b></code> &#47;&#47; 3 dimensions, 3 x 3 x 3
</blockquote>

<p>This initialisation rule occurs at the head of the script, outside
any procedure.  On initialisation, each table element or cell contains
the value zero.
</p><p>
Typically, a loop might be used to fill the table. The [20] in the example above (table MANY) is the number of items in the table, accessed via the loop count.  The [2] is the number of dimensions in the table, i.e., 2 columns.  Thus we would index [k][0] for the 1st column and [k][1] for the 2nd column.

</p><p>
It is also possible to create a table without a fixed size. The table is declared with no number within the brackets and its size is determined when it is filled from a file, using <b>fill_table</b>:
</p>
	<blockquote>
	<code><b>table NEWTABLE[]</b><br>
	<b>NEWTABLE fill_table "tabledata.txt"</b></code>
	</blockquote>
<p>
However, multi-dimension tables must have their dimensions and sizes declared, as shown above. 
</p>
<h3>String tables</h3>
<p>
String tables are identified by prefixing the character <b>'</b> to the table name:
</p>
	<blockquote>
	<code><b>table 'SNDSTABLE[8]</b></code> &nbsp; or<br>
	<code><b>table 'SNDSTABLE[]</b></code>  &nbsp;&nbsp; [followed by a <b>fill_table</b> statement]
	</blockquote>
<p>
Multi-dimension string tables are not supported. 
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>


<h2 id="TIME"><b>time</b> &#150; Rule</h2>

<blockquote>
<p>
Set a real-time counter.  Example:
</p>

<blockquote>
<code><b>t time</b></code>
</blockquote>

<p>
This places system time in cell 't', initialised to zero.  On subsequent
calls to <b>time</b> in the performance loop, the value of the cell
is incremented in pace with real-time.
</p>

<p>
By processing this value, warped time may be created, e.g.:
</p>

<pre><code><blockquote><b>
start()
{
     a       sum     a, 0.0005
     t       time
     warp    mult    t, a
             probe   t, warp
     if(warp &gt;= 100) {
          end
     }
loop
}
</b></blockquote></code></pre>

<h3>
Rule Return Status:
</h3>

<p>
Always <b>1</b>
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>


<h2 id="TANGENT"><b>tangent</b> &#150; Mathematical Function</h2>

<blockquote>
<p>
The tangent function.
<p>
Example:
</p>
<blockquote>
<code><b>
a = tangent(b)
</b></code>
</blockquote>
<p>
Cell 'a' will store the tangent of the value in cell 'b'.
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>

<h2 id="TRIGGER"><b>trigger</b> &#150; Rule</h2>

<blockquote>
<p>
Set a trigger cell.
</p>

<p>
Prototype:
</p>

<blockquote>
<code><b>tr1 trigger timevalue</b></code>
</blockquote>

<p>
Result: 'tr1' is made positive each time 'timevalue' has elapsed
</p>

<p>
Example:
</p>

<pre><code><blockquote><b>
a trigger 0.5
if(a &gt; 0) {
     pch sum pch, interval
}
</b></blockquote></code></pre>

<h3>
Rule Return Status:
</h3>

<p>
<b>1</b> if trigger is operating normally<br>
<b>0</b> if the output cell is locked.
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>


<h2 id="TRYRULE"><b>try</b> &#150; Mathematical Function</h2>

<blockquote>
<p>
<b>try</b> is a special mathematical function which permits the user
to ascertain the return status of a rule.  It therefore takes the form
</p>

<blockquote>
<code><b>try(rule)</b></code>
</blockquote>

<p>
where <b>rule</b> is the complete rule-line used in a <i>Tabula
Vigilans</i> script.  The meaning of the return status is given at
the end of each Manual entry for a Rule.  Typically the return
status means <b>1</b> for 'success' or 'normal operation' and <b>0</b>
means 'failure' or 'abnormal operation' &#150; but there are many
exceptions and the user should check the Manual in cases of doubt.
It is also important to realise that <b>try</b> applies only to rules
&#150; not to mathematical functions or to control-flow keywords.
</p>

<p>
It is possible to set a cell to store the result of <b>try</b>, as in:
</p>

<blockquote>
<code><b>x = try(midiout 0, note, 96, dur, 3)</b></code>
</blockquote>

<p>
and subsequently display it, as:
</p>

<blockquote>
<code><b>probi x</b></code>
</blockquote>

<p>
Or in an even more direct form:
</p>

<blockquote>
<code><b>probi try(midiout 0, note, 96, dur, 3)</b></code>
</blockquote>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>


<h2 id="UNLOCK"><b>unlock</b> &#150; Rule</h2>

<blockquote>
<p>
Unlocks previously locked input cells. (See <b>lock</b>, above.) Example:
</p>

<blockquote>
<code><b>unlock a, b, c</b></code>
</blockquote>

<h3>
Rule Return Status:
</h3>

<p>
Always <b>0</b>
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>


<h2 id="WAIT"><b>wait</b> &#150; Rule</h2>

<blockquote>
<p>
Cause a complete stay of execution for the duration of the input cell, as in:
</p>

<blockquote>
<code><b>wait 2.3</b></code>
</blockquote>

<p>
Everything will be on hold for 2.3 seconds.
</p>

<p>
<b>NB</b> &shy; Since the normal <i>Tabula Vigilans</i> performance of
a script is completely stopped by <b>wait</b>, this rule should be used
with care.  The only exception to the halt is that MIDI events already
started and previously scheduled to terminate (as in <b>midiout</b>
and <b>midichord</b>) will terminate correctly after their elapsed
duration.
</p>

<h3>
Rule Return Status:
</h3>

<p>
Always <b>1</b>
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>


<h2 id="WHILERULE"><b>while</b> &#150; Control-Flow</h2>

<blockquote>
<p>
Set up a locally-executing loop dependent upon the evaluation of a
test placed inside parentheses.
</p>

<p>
The form of the while clause is:
</p>

<pre><code><blockquote>
<b>while(some condition is TRUE ) {
     execute this block of rules
     ....
     ....
}
[and if the condition is not true, jump over the block and come here ]
....
....[etc.]</b>
</blockquote></code></pre>

<p>
The following
</p>

<pre><code><blockquote>
<b>while(1) {
     ....
}</b>
</blockquote></code></pre>

<p>
will always execute, because 1 is always true.
</p>

<p>
The test condition is evaluated using the usual relational operators
&#150; see Section 3.3.  Examples:
</p>

<pre><code><blockquote>
<b>while(x &lt; 100) {
    ....
    ....
}

while(y &gt; z &amp;&amp; a == 0) {
    ....
    ....
}</b></blockquote></code></pre>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>


<h2 id="XAD"><b>xad</b> &#150; Rule<br>
<a name="XAR"><b>xar</b></a> &#150; Rule
</h2>

<blockquote>
<p>
Prototypes:
</p>

<blockquote>
<b>B xad A</b>      &#47;&#47; eXtract Adjacent Differences<br>
<b>B xar A</b>      &#47;&#47; eXtract Adjacent Ratios
</blockquote>

<p>
These rules extract the differences (<b>xad</b>) or ratios (<b>xar</b>)
between adjacent values in the input table, and write them to the
output table, optimally wrapping beginning to end.  If the tables are
of different sizes, the output table will be either truncated or will
contain zeros.
</p>

<p>
Examples:
</p>

<p>
Suppose we have a one dimensional input table A[4] as follows:
</p>

	<blockquote>
	<p>
	<code>A: [3.31] [2.76] [7.13] [9.25]</code>
	</p>

	<p>
	then <code><b>B xad A</b></code> will place in output table B[4]:<br>
	B: [-0.55] [4.37]  [2.12]  [-5.94]
	</p>

	<p>
	and <code><b>C xar A</b></code> will place in output table C[4]:<br>
	<code>C: [0.83]  [2.58]  [1.30]  [0.36]</code>
	</p>
	</blockquote>

<h3>
Rule Return Status:
</h3>

<p>
<b>xad</b> &#150; Always <b>1</b><br>
<b>xar</b> &#150; Always <b>1</b>
</p>
</blockquote>

<p>
<a href="#TVFUNCCHART"><b>Return</b></a> to TV Rule Buttons<br>
<a href="#INDEXTOP"><b>Return</b></a>
to TV Index
</p>



<hr><!------------------------- DEMO SCRIPTS -------------------------->
<h1 id="DEMO">DEMONSTRATION SCRIPTS</h1>

<p>
<b>NB</b> These demonstration scripts illustrate aspects of control-flow
operations rather than musical uses of <i>Tabula Vigilans</i>. For the
latter, see Richard Orton <i>Principles of Algorithmic Musical
Composition</i> (forthcoming), or the disk of <i>Tabula Vigilans</i>
script examples distributed with the CDP release.
</p>

<pre>
<code>

<!--
///////////////////////////////////////////////////////////////////
//			'spawnplay.tv'
//
// A Tabula Vigilans script showing the use of 'spawn' to initiate
// playing a soundfile, while a MIDI performance continues.
//////////////////////////////////////////////////////////////////
start()
{
	message "\nPlaying a soundfile in the middle of a MIDI performance.\n"
	midiset 0, 0
	pch = 60
	while(pch <= 96) {
		t time
		xx = try(midiout 0, pch, 80, 1.0, 1)
		if(xx > 0) {
			pch += 1
		}
		if(played == 0 && t >= 10.00) {		// At ten seconds,
			spawn "playsfx -i D:/a1.wav"	// initiate playing the soundfile 'a1.wav'.
			played = 1
		}
	}
}

-->

///////////////////////////////////////////////////////////////
// An example Tabula Vigilans script showing call() with
// parameters and break with and without labels (in this case
// 'fred' and 'jane')
///////////////////////////////////////////////////////////////
start()
{
        message "Starting...\n"
        for fred (f = 0; f &lt; 10; f+=1) {
                call sub1(f)
        }
        message "Fred is finished."
        while jane (j++ &lt; 5) {
                call sub2(j)
        }
        message "\nJane is finished."
        for(k = 0; k &lt; 10000; k+=1) {
                if(k == 273) {
                        message "\nKey number is"
                        probi k
                        message "\n\tIt's time to end....\n"
                        break
                }
}
<p>
sub1(x)
{
        if(x &lt; 5) {
                message "This is Fred's time number"
                probi x
                message "\n"
        }
        else {
                break fred
        }
}
<p>
sub2(y)
{
        if(y &gt;= 3) {
                break jane
        }
        else {
                message "\nJane is here!"
        }
}
<p>
<p>
///////////////////////////////////////////////////////////////
//
// An example Tabula Vigilans script showing call() with
// parameters and continue with and without labels
// ('fred' and 'jane')
//
///////////////////////////////////////////////////////////////
start()
{
        message "Starting...\n"
        for fred (i = 1; i &lt; 10; i+=1) {
                if(i &gt; 5) {
                        message "\nDone it"
                }
                else {
                        call sub1(i)
                }
        }
        message "\nFred is finished."
        while jane (j++ &lt; 5) {
                call sub2(j)
        }
        message "\nJane is finished."
        for(k = 0; k &lt; 10000; k+=1) {
                if(k == 273) {
                        message "\nKey number is"
                        probi k++
                        message "\n\tIt's time to end....\n"
                        continue
                }
                if(k == 317) {
                        message "Not quite: Key number now"
                        probi k
                        message "\nWe'll finish now!"
                        break
                }
        }
        end
}
<p>
sub1(x)
{
        if(x &lt; 6) {
                message "This is Fred's time number"
                probi x
                message "\n"
        }
        else {
                continue fred
        }
}
<p>
sub2(y)
{
        if(y &gt;= 3) {
                continue jane
        }
        else {
                message "\nJane is here!"
        }
}
<p>
// File "tab1", containing a set of 8 midinotes:
62 65 70 71 72 63 66 67
<p>
// File "tab2", containing a set of 9 midinotes:
71 72 63 66 67 64 68 69 73
<p>
<p>
///////////////////////////////////////////////////////////////
// Tabula Vigilans script "compare.tv"
// demonstrating the use of 'compare'
///////////////////////////////////////////////////////////////
table   AAA[8]
table   BBB[9]
table   CCC[5]
<p>
start()
{
    AAA fill_table "tab1"
    BBB fill_table "tab2"
    sect = 1
    CCC compare AAA, BBB, 0
    message "Section 1: Table A\n"
    while(1) {
        if(sect == 1) {
            if(xx &gt; 0) {
                a = AAA[andx++]
            }
            if(count &gt; 24) {
                count = 0
                sect = 2
                message "Section 2: Table B\n"
                wait 2.0
            }
        }
        if(sect == 2) {
            if(xx &gt; 0) {
                a = BBB[bndx++]
            }
            if(count &gt;= 27) {
                count = 0
                sect = 3
                message "Section 3: Table C: Intersection of Table A &amp; B\n"
                wait 2.0
            }
        }
        if(sect == 3) {
            if(xx &gt; 0) {
                a = CCC[cndx++]
            }
            if(count &gt;= 20) {
                end
            }
        }
        xx = try(midiout 0, a, 64, 0.2, 1)
        if(xx &gt; 0) {
            count += 1
        }
    }
}
<p>
<p>
///////////////////////////////////////////////////
//
// Demonstration Tabula Vigilans script for 'copy'
//
///////////////////////////////////////////////////
start()
{
        d = 7.73
        message "At start: a, b, c, d are \t"
        probe a, b, c, d
        message "\nNow copying value of d into a, b, c:"
        a, b, c  copy d
        message "\nNow, cells a, b, c, d are \t"
        probe a, b, c, d
        message "\n"
}
<p>
<p>
////////////////////////////////////////////////////
//
//  Demonstration Tabula Vigilans
//   script for table copying
//
////////////////////////////////////////////////////
table TABLE1[4]
table TABLE2[4]
<p>
start()
{
    TABLE1 fill_table "input1"
<p>
    message "Input Table is:\n"
    probe TABLE1[0], TABLE1[1], TABLE1[2], TABLE1[3]
    message "\n"
    TABLE2 copy_table TABLE1
    TABLE1[0] = 77
    TABLE1[1] = 78
    TABLE1[2] = 79
    TABLE1[3] = 80
    message "Output (copied) Table is:\n"
    probe TABLE2[0], TABLE2[1], TABLE2[2], TABLE2[3]
}
<p>
<p>
////////////////////////////////////////////
//
// Demonstration Tabula Vigilans script:
//   use of dimsize
//
////////////////////////////////////////////
table TAB[10][5]
<p>
start()
{
        message "dimensions(TAB)  = \t"
        probi dimensions(TAB)
        message "\n"
<p>
        TAB1 copy TAB
<p>
        message "dimensions(TAB1) = \t"
        probi dimensions(TAB1)
        message "\n"
<p>
        call x(TAB)
}
<p>
x(T)
{
        message "dimensions(T) = \t"
        probi dimensions(T)
        message "\n"
        message "Size of dimension 1 is\t"
        probi dimsize(T, 1)
        message "\n"
        message "Size of dimension 2 is\t"
        probi dimsize(T, 2)
        message "\n"

        T[0][0] copy 11.23
        T[2][1] copy 57.82
        T[8][2] copy 93.77

        for(a = 0; a &lt; 10; a += 1) {
                T[a][a+1] copy a*a
        }
        message "Table initialized\n"
        for(a = 0; a &lt; 10; a += 1) {
                call prrow(T, a)
        }
}
<p>
prrow(T, row)
{
        for(cnt = 0; cnt &lt; dimsize(T, 2); cnt += 1) {
                print T[row][cnt]
                message "\t"
        }
        message "\n"
}
</code>
</pre>

<!-- end of tvm6ae.htm -->


<!-- ********************************************************** -->
  <div id = "footer">
   <p>
    <address>
    Last updated 17 Sep 2023; revisions: A. Endrich and R. Fraser<br> 
    Text last updated: 28 Sep 2023 for vn. 1.5f<br> 
    <b>&#169; 1994-2012, Richard Orton,Willoughby on the Wolds &amp; Composers' Desktop Project</b>
    </address>
   </p>
  </div>

</div> <!-- End of 'right' (contents) indentation -->


</body>

</html>
